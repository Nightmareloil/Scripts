--[[
    2TAKE1 ULTRA - Pro Version (Latest 2026)
    Optimized for performance while maintaining all features
    All commands, buttons, and features preserved
]]
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Services = {
    TextChat = game:GetService("TextChatService"),
    UIS = game:GetService("UserInputService"),
    Tween = game:GetService("TweenService"),
    Run = game:GetService("RunService"),
    Teleport = game:GetService("TeleportService"),
    Http = game:GetService("HttpService"),
    StarterGui = game:GetService("StarterGui"),
    Stats = game:GetService("Stats"),
    Debris = game:GetService("Debris"),
    Lighting = game:GetService("Lighting"),
    SoundService = game:GetService("SoundService")
}
if not game:IsLoaded() then game.Loaded:Wait() end
-- Performance Tracking
local Performance = {fps = 0, ping = 0}
-- Farm Configuration with speed options
local FARM_CONFIG = {
    SLOW_MULTIPLIER = 0.5,
    FAST_MULTIPLIER = 1.0,
    DELAY = 0.08
}
-- Sound System
local Sounds = {}
local soundIds = {
    hover = "rbxassetid://7218169592",
    click = "rbxassetid://7212399604",
    open = "rbxassetid://6655851046",
    close = "rbxassetid://2767090",
    success = "rbxassetid://113724958425026",
    error = "rbxassetid://2130284653",
    typing = "rbxassetid://4723761654",
    combat = "rbxassetid://9043341746",
    shield = "rbxassetid://6655851046"
}
local function createSounds()
    local soundFolder = Instance.new("Folder")
    soundFolder.Name = "2take1Sounds"
    soundFolder.Parent = Services.SoundService
    for name, id in pairs(soundIds) do
        local sound = Instance.new("Sound")
        sound.SoundId = id
        sound.Volume = name == "typing" and 0.12 or name == "hover" and 0.18 or 0.35
        sound.Parent = soundFolder
        pcall(function() sound:Play() sound:Stop() end)
        Sounds[name] = sound
    end
end
createSounds()
-- Input Management
local InputManager = {
    cooldowns = {},
    globalCooldown = 0,
    minInputDelay = 0.1,
    buttonCooldown = 0.2,
    commandCooldown = 0.25
}
local function playSound(soundName)
    local currentTime = time()
    if currentTime - InputManager.globalCooldown < 0.05 then return end
    local sound = Sounds[soundName]
    if sound then
        task.spawn(function() pcall(function() sound:Play() end) end)
        InputManager.globalCooldown = currentTime
    end
end
local function canExecuteInput(inputId, cooldownType)
    local currentTime = time()
    local cooldownTime = InputManager.minInputDelay
    if cooldownType == "button" then cooldownTime = InputManager.buttonCooldown
    elseif cooldownType == "command" then cooldownTime = InputManager.commandCooldown end
    local lastTime = InputManager.cooldowns[inputId] or 0
    if currentTime - lastTime >= cooldownTime then
        InputManager.cooldowns[inputId] = currentTime
        return true
    end
    return false
end
-- UI Scaling
local UIScale = {
    userScale = 1.0,
    desktop = {minScale = 0.75, maxScale = 2.5, baseReferenceSize = 1080},
    mobile = {minScale = 0.80, maxScale = 1.5, baseReferenceSize = 1980},
    tablet = {minScale = 0.65, maxScale = 2.0, baseReferenceSize = 1366},
    cached = {scale = nil, mobile = nil, deviceType = nil}
}
local function detectDeviceType()
    local viewport = workspace.CurrentCamera.ViewportSize
    local hasTouch = Services.UIS.TouchEnabled
    local hasKeyboard = Services.UIS.KeyboardEnabled
    local hasMouse = Services.UIS.MouseEnabled
   
    if hasTouch and not hasKeyboard and not hasMouse then
        local screenWidth = viewport.X
        local aspectRatio = screenWidth / viewport.Y
        if screenWidth >= 768 or (aspectRatio > 0.65 and aspectRatio < 0.8) then
            return "tablet"
        else
            return "mobile"
        end
    else
        return "desktop"
    end
end
local function getOptimizedScaleFactor()
    if UIScale.cached.scale and UIScale.cached.deviceType then
        return UIScale.cached.scale, UIScale.cached.deviceType == "mobile", UIScale.cached.deviceType
    end
   
    local viewport = workspace.CurrentCamera.ViewportSize
    local deviceType = detectDeviceType()
    local deviceSettings = UIScale[deviceType]
    local screenHeight = viewport.Y
    local screenWidth = viewport.X
    local baseScale = screenHeight / deviceSettings.baseReferenceSize
   
    if deviceType == "mobile" then
        if screenWidth > screenHeight then
            baseScale = math.min(baseScale, screenWidth / 2560) * 0.85
        else
            if screenWidth < 400 then
                baseScale = baseScale * 0.8
            end
        end
    elseif deviceType == "tablet" then
        if screenWidth > screenHeight then
            baseScale = baseScale * 0.9
        end
    end
   
    local finalScale = baseScale * UIScale.userScale
    finalScale = math.clamp(finalScale, deviceSettings.minScale, deviceSettings.maxScale)
   
    UIScale.cached.scale = finalScale
    UIScale.cached.mobile = (deviceType == "mobile")
    UIScale.cached.deviceType = deviceType
   
    return finalScale, (deviceType == "mobile"), deviceType
end
local scaleFactor, isMobile, deviceType = getOptimizedScaleFactor()
local function S(offset)
    local scaled = offset * scaleFactor
    return math.max(1, math.floor(scaled + 0.5))
end
local function updateUIScale()
    UIScale.cached = {scale = nil, mobile = nil, deviceType = nil}
    scaleFactor, isMobile, deviceType = getOptimizedScaleFactor()
end
local function getTextScale()
    if deviceType == "mobile" then return scaleFactor * 0.95
    elseif deviceType == "tablet" then return scaleFactor * 1.0
    else return scaleFactor * 1.05 end
end
local function TS(baseSize)
    return math.max(8, math.floor(baseSize * getTextScale() + 0.5))
end
-- Configuration
local Config = {
    speed = 4,
    range = S(15),
    walkSpeed = 22,
    jumpPower = 50,
    flySpeed = S(40),
    killAuraRange = 30,
    commandPrefix = ";",
    whitelistedIds = {1212018424, 514967933}
}
-- State Management
local State = {
    fastFarm = false,
    slowFarm = false,
    godMode = false,
    killAura = false,
    flying = false,
    noclip = false,
    commandBarVisible = false,
    loopKillActive = false,
    loopKillConnections = {},
    watchingPlayer = nil,
    reverseDmg = false,
    speedHack = false,
    protectedPlayer = nil,
    protectionActive = false,
    isMinimized = false,
    coroutines = {},
    killFarmActive = false,
    killFarmTarget = nil,
    killFarmConnection = nil
}
-- Statistics
local Stats = {
    power = 0,
    kills = 0,
    health = 100,
    sessionStartTime = time(),
    powerPerSecond = 0,
    powerPerHour = 0,
    initialPower = 0,
    farmingTime = 0,
    powerGainedFarming = 0,
    farmStartPower = 0
}
-- Data Storage
local Data = {
    adminPlayers = {},
    connections = {},
    flyObjects = {},
    noclipConnection = nil,
    flyConnection = nil,
    charDiedFlyConnection = nil,
    watchConnection = nil,
    speedConnections = {},
    uiElements = {},
    protectionConnection = nil,
    protectedPlayerConnection = nil,
    protectionHeartbeat = nil,
    protectionCleanup = nil,
    toolCache = {},
    originalUISize = nil,
    lastUpdateTime = 0
}
-- Theme Colors
local Theme = {
    background = Color3.fromRGB(18, 18, 28),
    backgroundGlass = Color3.fromRGB(25, 25, 38),
    secondary = Color3.fromRGB(35, 35, 50),
    tertiary = Color3.fromRGB(45, 45, 65),
    accent = Color3.fromRGB(80, 150, 220),
    accentSecondary = Color3.fromRGB(120, 180, 240),
    accentGradient1 = Color3.fromRGB(80, 150, 220),
    accentGradient2 = Color3.fromRGB(120, 180, 240),
    success = Color3.fromRGB(100, 210, 130),
    danger = Color3.fromRGB(230, 90, 90),
    warning = Color3.fromRGB(230, 190, 70),
    info = Color3.fromRGB(110, 160, 210),
    text = Color3.fromRGB(240, 240, 245),
    textSecondary = Color3.fromRGB(180, 180, 200),
    textMuted = Color3.fromRGB(140, 140, 160),
    glow = Color3.fromRGB(120, 170, 230),
    glassBorder = Color3.fromRGB(200, 200, 220),
    glassReflection = Color3.fromRGB(255, 255, 255),
    protection = Color3.fromRGB(200, 170, 80),
    heal = Color3.fromRGB(130, 210, 110),
    damage = Color3.fromRGB(210, 110, 150),
    proGold = Color3.fromRGB(255, 215, 0),
    proGradient1 = Color3.fromRGB(255, 215, 0),
    proGradient2 = Color3.fromRGB(255, 165, 0)
}
-- Utility Functions
local function protectGui(gui)
    if syn and syn.protect_gui then
        syn.protect_gui(gui)
    elseif gethui then
        gui.Parent = gethui()
        return
    end
    pcall(function() gui.Parent = game:GetService("CoreGui") end)
end
local function notification(text, duration, type)
    if not canExecuteInput("notification", "button") then return end
    duration = duration or 3
    local iconMap = {
        success = "rbxassetid://7743878358",
        error = "rbxassetid://7743877738",
        warning = "rbxassetid://7743878496",
        combat = "rbxassetid://7743878358"
    }
    local icon = iconMap[type] or "rbxassetid://7733964640"
    if type and type ~= "info" then
        playSound(type == "combat" and "combat" or type)
    end
    pcall(function()
        Services.StarterGui:SetCore("SendNotification", {
            Title = "2TAKE1 ULTRA 2026",
            Text = text,
            Duration = duration,
            Icon = icon
        })
    end)
end
local formatRanges = {{1e12, "T"}, {1e9, "B"}, {1e6, "M"}, {1e3, "K"}}
local function formatNumber(n)
    if not n or n == math.huge or n == -math.huge then return "Inf" end
    for _, range in ipairs(formatRanges) do
        if n >= range[1] then
            return string.format("%.2f%s", n/range[1], range[2])
        end
    end
    return tostring(math.floor(n))
end
local function formatTimeMinutes(s)
    local mins = math.floor(s / 60)
    local secs = math.floor(s % 60)
    return string.format("%02d:%02d", mins, secs)
end
local function formatTime(s)
    local days = math.floor(s / 86400)
    s = s % 86400
    local hours = math.floor(s / 3600)
    s = s % 3600
    local mins = math.floor(s / 60)
    local secs = math.floor(s % 60)
   
    if days > 0 then
        return string.format("%dd %02d:%02d:%02d", days, hours, mins, secs)
    else
        return string.format("%02d:%02d:%02d", hours, mins, secs)
    end
end
local function makeDraggable(frame, handle)
    handle = handle or frame
    local dragging, dragStart, startPos = false, nil, nil
    local dragInput
   
    -- Touch support for mobile
    local function updateInput(input)
        if dragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end
   
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
           
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
   
    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
   
    Services.UIS.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateInput(input)
        end
    end)
end
local function addCornerAndStroke(obj, radius, color, strokeWidth)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or S(10))
    corner.Parent = obj
    if color then
        local stroke = Instance.new("UIStroke")
        stroke.Thickness = strokeWidth or S(1)
        stroke.Color = color
        stroke.Transparency = 0.4
        stroke.Parent = obj
    end
end
local function createScalableElement(obj, sizeOffsets, positionOffsets, textSize, cornerRadius)
    local elementData = {
        obj = obj,
        size = sizeOffsets and UDim2.new(sizeOffsets.X.Scale, sizeOffsets.X.Offset, sizeOffsets.Y.Scale, sizeOffsets.Y.Offset),
        position = positionOffsets and UDim2.new(positionOffsets.X.Scale, positionOffsets.X.Offset, positionOffsets.Y.Scale, positionOffsets.Y.Offset),
        textSize = textSize,
        cornerRadius = cornerRadius
    }
    table.insert(Data.uiElements, elementData)
    return elementData
end
-- Create Main GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "2take1HubUltra"
screenGui.ResetOnSpawn = false
protectGui(screenGui)
-- Performance Display
local performanceFrame = Instance.new("Frame")
performanceFrame.Size = UDim2.new(0, S(180), 0, S(60))
performanceFrame.Position = UDim2.new(1, -S(190), 0, S(10))
performanceFrame.BackgroundColor3 = Theme.backgroundGlass
performanceFrame.BorderSizePixel = 0
performanceFrame.BackgroundTransparency = 0.4
performanceFrame.Parent = screenGui
addCornerAndStroke(performanceFrame, S(10), Theme.glassBorder, S(1))
local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
fpsLabel.Position = UDim2.new(0, S(5), 0, 0)
fpsLabel.BackgroundTransparency = 1
fpsLabel.Text = "FPS: 0"
fpsLabel.TextColor3 = Theme.success
fpsLabel.TextSize = S(11)
fpsLabel.Font = Enum.Font.GothamBold
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Parent = performanceFrame
local pingLabel = Instance.new("TextLabel")
pingLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
pingLabel.Position = UDim2.new(0.5, 0, 0, 0)
pingLabel.BackgroundTransparency = 1
pingLabel.Text = "Ping: 0ms"
pingLabel.TextColor3 = Theme.info
pingLabel.TextSize = S(11)
pingLabel.Font = Enum.Font.GothamBold
pingLabel.TextXAlignment = Enum.TextXAlignment.Left
pingLabel.Parent = performanceFrame
local perfStatsLabel = Instance.new("TextLabel")
perfStatsLabel.Size = UDim2.new(1, -S(10), 0.5, 0)
perfStatsLabel.Position = UDim2.new(0, S(5), 0.5, 0)
perfStatsLabel.BackgroundTransparency = 1
perfStatsLabel.Text = "Memory: 0MB"
perfStatsLabel.TextColor3 = Theme.textSecondary
perfStatsLabel.TextSize = S(9)
perfStatsLabel.Font = Enum.Font.Gotham
perfStatsLabel.TextXAlignment = Enum.TextXAlignment.Left
perfStatsLabel.Parent = performanceFrame
local function updatePerformanceMetrics()
    local fpsColor = Performance.fps >= 55 and Theme.success or Performance.fps >= 28 and Theme.warning or Theme.danger
    fpsLabel.Text = "FPS: " .. Performance.fps
    fpsLabel.TextColor3 = fpsColor
   
    local pingStat = Services.Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then
        Performance.ping = math.floor(pingStat:GetValue() or 0)
        local pingColor = Performance.ping <= 80 and Theme.success or Performance.ping <= 150 and Theme.warning or Theme.danger
        pingLabel.Text = "Ping: " .. Performance.ping .. "ms"
        pingLabel.TextColor3 = pingColor
    else
        pingLabel.Text = "Ping: N/A"
        pingLabel.TextColor3 = Theme.textMuted
    end
   
    local memoryMB = math.floor(Services.Stats:GetTotalMemoryUsageMb())
    perfStatsLabel.Text = "Memory: " .. memoryMB .. "MB"
end
-- Command Bar
local commandBar = Instance.new("Frame")
commandBar.Size = UDim2.new(0, S(isMobile and 300 or 400), 0, S(isMobile and 45 or 55))
commandBar.Position = UDim2.new(0.5, -S(isMobile and 150 or 200), 1, S(100))
commandBar.BackgroundColor3 = Theme.backgroundGlass
commandBar.BorderSizePixel = 0
commandBar.BackgroundTransparency = 0.3
commandBar.ClipsDescendants = true
commandBar.Parent = screenGui
makeDraggable(commandBar)
addCornerAndStroke(commandBar, S(12), Theme.glassBorder, S(1))
local bgGradient1 = Instance.new("UIGradient")
bgGradient1.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Theme.backgroundGlass), ColorSequenceKeypoint.new(1, Theme.secondary)}
bgGradient1.Rotation = 90
bgGradient1.Parent = commandBar
local glassOverlay = Instance.new("Frame")
glassOverlay.Size = UDim2.new(1, 0, 0.4, 0)
glassOverlay.Position = UDim2.new(0, 0, 0, 0)
glassOverlay.BackgroundColor3 = Theme.glassReflection
glassOverlay.BackgroundTransparency = 0.9
glassOverlay.BorderSizePixel = 0
glassOverlay.Parent = commandBar
local accentLine = Instance.new("Frame")
accentLine.Size = UDim2.new(1, 0, 0, S(1))
accentLine.Position = UDim2.new(0, 0, 1, -S(1))
accentLine.BackgroundColor3 = Theme.accent
accentLine.BorderSizePixel = 0
accentLine.BackgroundTransparency = 0.35
accentLine.Parent = commandBar
local cmdIcon = Instance.new("Frame")
cmdIcon.Size = UDim2.new(0, S(35), 0, S(35))
cmdIcon.Position = UDim2.new(0, S(10), 0.5, -S(17.5))
cmdIcon.BackgroundColor3 = Theme.accent
cmdIcon.BackgroundTransparency = 0.8
cmdIcon.Parent = commandBar
addCornerAndStroke(cmdIcon, S(8), Theme.accent, S(1))
local iconLabel = Instance.new("TextLabel")
iconLabel.Size = UDim2.new(1, 0, 1, 0)
iconLabel.BackgroundTransparency = 1
iconLabel.Text = ""
iconLabel.TextColor3 = Theme.text
iconLabel.TextSize = S(isMobile and 18 or 22)
iconLabel.Font = Enum.Font.SourceSansBold
iconLabel.Parent = cmdIcon
local inputContainer = Instance.new("Frame")
inputContainer.Size = UDim2.new(1, -S(isMobile and 140 or 180), 0, S(35))
inputContainer.Position = UDim2.new(0, S(isMobile and 50 or 60), 0.5, -S(17.5))
inputContainer.BackgroundColor3 = Theme.secondary
inputContainer.BackgroundTransparency = 0.6
inputContainer.Parent = commandBar
addCornerAndStroke(inputContainer, S(8), Theme.glassBorder, S(1))
local cmdInput = Instance.new("TextBox")
cmdInput.Size = UDim2.new(1, -S(14), 1, -S(5))
cmdInput.Position = UDim2.new(0, S(7), 0, S(2.5))
cmdInput.BackgroundTransparency = 1
cmdInput.Text = ""
cmdInput.PlaceholderText = "Type command here..."
cmdInput.PlaceholderColor3 = Theme.textMuted
cmdInput.TextColor3 = Theme.text
cmdInput.TextSize = S(isMobile and 12 or 14)
cmdInput.Font = Enum.Font.Gotham
cmdInput.TextXAlignment = Enum.TextXAlignment.Left
cmdInput.Parent = inputContainer
local typingIndicator = Instance.new("Frame")
typingIndicator.Size = UDim2.new(0, S(2), 0, S(16))
typingIndicator.Position = UDim2.new(0, S(7), 0.5, -S(8))
typingIndicator.BackgroundColor3 = Theme.accent
typingIndicator.BorderSizePixel = 0
typingIndicator.Visible = false
typingIndicator.Parent = inputContainer
local execBtn = Instance.new("TextButton")
execBtn.Size = UDim2.new(0, S(isMobile and 70 or 90), 0, S(35))
execBtn.Position = UDim2.new(1, -S(isMobile and 80 or 100), 0.5, -S(17.5))
execBtn.BackgroundColor3 = Theme.accent
execBtn.Text = ""
execBtn.AutoButtonColor = false
execBtn.Parent = commandBar
addCornerAndStroke(execBtn, S(8), Theme.accent, S(1))
local btnGradient = Instance.new("UIGradient")
btnGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Theme.accentGradient1), ColorSequenceKeypoint.new(1, Theme.accentGradient2)}
btnGradient.Rotation = 135
btnGradient.Parent = execBtn
local btnText = Instance.new("TextLabel")
btnText.Size = UDim2.new(1, 0, 1, 0)
btnText.BackgroundTransparency = 1
btnText.Text = "RUN"
btnText.TextColor3 = Theme.text
btnText.TextSize = S(isMobile and 10 or 12)
btnText.Font = Enum.Font.GothamBold
btnText.Parent = execBtn
local btnHovering = false
execBtn.MouseEnter:Connect(function()
    if not canExecuteInput("btnHover", "button") then return end
    btnHovering = true
    playSound("hover")
    Services.Tween:Create(execBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, S(isMobile and 75 or 95), 0, S(37))}):Play()
end)
execBtn.MouseLeave:Connect(function()
    btnHovering = false
    Services.Tween:Create(execBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(0, S(isMobile and 70 or 90), 0, S(35))}):Play()
end)
execBtn.MouseButton1Down:Connect(function()
    if not canExecuteInput("btnPress", "button") then return end
    Services.Tween:Create(execBtn, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(0, S(isMobile and 68 or 88), 0, S(33))}):Play()
end)
execBtn.MouseButton1Up:Connect(function()
    local targetSize = btnHovering and UDim2.new(0, S(isMobile and 75 or 95), 0, S(37)) or UDim2.new(0, S(isMobile and 70 or 90), 0, S(35))
    Services.Tween:Create(execBtn, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = targetSize}):Play()
end)
-- Typing indicator animation
local typingTween = nil
cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
    if cmdInput.Text ~= "" then
        typingIndicator.Visible = true
        if not typingTween then
            typingTween = Services.Tween:Create(typingIndicator, TweenInfo.new(0.7, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true), {BackgroundTransparency = 0.5})
            typingTween:Play()
        end
        if math.random() > 0.8 and canExecuteInput("typing", "button") then
            playSound("typing")
        end
    else
        typingIndicator.Visible = false
        if typingTween then
            typingTween:Cancel()
            typingTween = nil
        end
    end
end)
-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, S(isMobile and 350 or 450), 0, S(isMobile and 550 or 650))
mainFrame.Position = UDim2.new(0.5, -S(isMobile and 175 or 225), 0.5, -S(isMobile and 275 or 325))
mainFrame.BackgroundColor3 = Theme.background
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = 0.2
mainFrame.ClipsDescendants = true
mainFrame.Parent = screenGui
addCornerAndStroke(mainFrame, S(14), Theme.glassBorder, S(1))
Data.originalUISize = mainFrame.Size
local mainGradient = Instance.new("UIGradient")
mainGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Theme.background), ColorSequenceKeypoint.new(0.5, Theme.secondary), ColorSequenceKeypoint.new(1, Theme.background)}
mainGradient.Rotation = 90
mainGradient.Parent = mainFrame
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, S(isMobile and 40 or 50))
header.BackgroundColor3 = Theme.secondary
header.BackgroundTransparency = 0.4
header.Parent = mainFrame
makeDraggable(mainFrame, header)
addCornerAndStroke(header, S(14))
local title = Instance.new("TextLabel")
title.Size = UDim2.new(0, S(120), 1, 0)
title.Position = UDim2.new(0, S(14), 0, 0)
title.BackgroundTransparency = 1
title.Text = "2TAKE1 ULTRA"
title.TextColor3 = Theme.text
title.TextSize = S(isMobile and 13 or 16)
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

-- Pro badge with enhanced styling
local proBadge = Instance.new("TextLabel")
proBadge.Size = UDim2.new(0, S(50), 0, S(22))
proBadge.Position = UDim2.new(0, S(140), 0.5, -S(11))
proBadge.BackgroundColor3 = Theme.proGradient1
proBadge.Text = "PRO"
proBadge.TextColor3 = Color3.fromRGB(0, 0, 0)
proBadge.TextSize = S(isMobile and 10 or 12)
proBadge.Font = Enum.Font.GothamBold
proBadge.Parent = header
addCornerAndStroke(proBadge, S(6))

local proGradient = Instance.new("UIGradient")
proGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.proGradient1),
    ColorSequenceKeypoint.new(1, Theme.proGradient2)
}
proGradient.Rotation = 45
proGradient.Parent = proBadge

local proStroke = Instance.new("UIStroke")
proStroke.Color = Color3.fromRGB(255, 255, 0)
proStroke.Thickness = S(1.5)
proStroke.Transparency = 0.3
proStroke.Parent = proBadge

-- Animated glow effect for PRO badge
task.spawn(function()
    while proBadge.Parent do
        Services.Tween:Create(proGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Rotation = 225}):Play()
        Services.Tween:Create(proStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.1}):Play()
        task.wait(2)
        Services.Tween:Create(proGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Rotation = 45}):Play()
        Services.Tween:Create(proStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.5}):Play()
        task.wait(2)
    end
end)

-- Year badge
local yearBadge = Instance.new("TextLabel")
yearBadge.Size = UDim2.new(0, S(48), 0, S(18))
yearBadge.Position = UDim2.new(0, S(196), 0.5, -S(9))
yearBadge.BackgroundColor3 = Theme.accent
yearBadge.BackgroundTransparency = 0.3
yearBadge.Text = "2026"
yearBadge.TextColor3 = Theme.text
yearBadge.TextSize = S(isMobile and 9 or 10)
yearBadge.Font = Enum.Font.GothamBold
yearBadge.Parent = header
addCornerAndStroke(yearBadge, S(5))

-- Resize button
local resizeBtn = Instance.new("TextButton")
resizeBtn.Size = UDim2.new(0, S(28), 0, S(28))
resizeBtn.Position = UDim2.new(1, -S(96), 0.5, -S(14))
resizeBtn.BackgroundColor3 = Theme.accent
resizeBtn.BackgroundTransparency = 0.3
resizeBtn.Text = "â‡²"
resizeBtn.TextColor3 = Theme.text
resizeBtn.TextSize = S(isMobile and 16 or 20)
resizeBtn.Font = Enum.Font.SourceSansBold
resizeBtn.AutoButtonColor = false
resizeBtn.Parent = header
addCornerAndStroke(resizeBtn, S(8))

resizeBtn.MouseEnter:Connect(function()
    if not canExecuteInput("resizeHover", "button") then return end
    playSound("hover")
    Services.Tween:Create(resizeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.1}):Play()
end)
resizeBtn.MouseLeave:Connect(function()
    Services.Tween:Create(resizeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.3}):Play()
end)

resizeBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("resizeClick", "button") then return end
    playSound("click")
    
    -- Only 3 size options: Small -> Medium -> Large -> Small
    local currentScale = UIScale.userScale
    
    if deviceType == "mobile" then
        -- Mobile: Small(0.8x) -> Medium(1.0x) -> Large(1.3x)
        if currentScale >= 1.3 then
            UIScale.userScale = 0.8  -- Small
        elseif currentScale >= 1.0 then
            UIScale.userScale = 1.3  -- Large
        else
            UIScale.userScale = 1.0  -- Medium
        end
    else
        -- Desktop: Small(0.8x) -> Medium(1.0x) -> Large(1.5x)
        if currentScale >= 1.7 then
            UIScale.userScale = 0.8  -- Small
        elseif currentScale >= 1.0 then
            UIScale.userScale = 1.3  -- Large
        else
            UIScale.userScale = 1.0  -- Medium
        end
    end
    
    -- Calculate new scale
    UIScale.cached = {scale = nil, mobile = nil, deviceType = nil}
    local oldScale = scaleFactor
    scaleFactor, isMobile, deviceType = getOptimizedScaleFactor()
    local ratio = scaleFactor / oldScale
    
    -- Resize main frame
    local w = math.floor(mainFrame.Size.X.Offset * ratio)
    local h = math.floor(mainFrame.Size.Y.Offset * ratio)
    mainFrame.Size = UDim2.new(0, w, 0, h)
    mainFrame.Position = UDim2.new(0.5, -w/2, 0.5, -h/2)
    Data.originalUISize = mainFrame.Size
    
    -- Resize all UI elements
    for _, obj in ipairs(screenGui:GetDescendants()) do
        if obj:IsA("GuiObject") and obj ~= screenGui then
            -- Scale size
            local sz = obj.Size
            obj.Size = UDim2.new(sz.X.Scale, math.floor(sz.X.Offset * ratio), sz.Y.Scale, math.floor(sz.Y.Offset * ratio))
            
            -- Scale position
            local ps = obj.Position
            obj.Position = UDim2.new(ps.X.Scale, math.floor(ps.X.Offset * ratio), ps.Y.Scale, math.floor(ps.Y.Offset * ratio))
        end
        
        -- Scale text
        if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
            obj.TextSize = math.max(8, math.floor(obj.TextSize * ratio))
        end
        
        -- Scale corners
        if obj:IsA("UICorner") then
            obj.CornerRadius = UDim.new(0, math.max(1, math.floor(obj.CornerRadius.Offset * ratio)))
        end
        
        -- Scale strokes
        if obj:IsA("UIStroke") then
            obj.Thickness = math.max(1, math.floor(obj.Thickness * ratio))
        end
        
        -- Scale scrollbars
        if obj:IsA("ScrollingFrame") then
            obj.ScrollBarThickness = math.max(2, math.floor(obj.ScrollBarThickness * ratio))
        end
    end
    
    -- Show size name
    local sizeName = currentScale <= 0.8 and "Small" or currentScale >= 1.3 and "Large" or "Medium"
    notification(string.format("UI Size: %s (%.1fx)", sizeName, UIScale.userScale), 2, "success")
end)

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, S(28), 0, S(28))
minimizeBtn.Position = UDim2.new(1, -S(64), 0.5, -S(14))
minimizeBtn.BackgroundColor3 = Theme.info
minimizeBtn.BackgroundTransparency = 0.3
minimizeBtn.Text = "-"
minimizeBtn.TextColor3 = Theme.text
minimizeBtn.TextSize = S(isMobile and 18 or 22)
minimizeBtn.Font = Enum.Font.SourceSansBold
minimizeBtn.AutoButtonColor = false
minimizeBtn.Parent = header
addCornerAndStroke(minimizeBtn, S(8))
minimizeBtn.MouseEnter:Connect(function()
    if not canExecuteInput("minimizeHover", "button") then return end
    playSound("hover")
    Services.Tween:Create(minimizeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.1}):Play()
end)
minimizeBtn.MouseLeave:Connect(function()
    Services.Tween:Create(minimizeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.3}):Play()
end)
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, S(28), 0, S(28))
closeBtn.Position = UDim2.new(1, -S(32), 0.5, -S(14))
closeBtn.BackgroundColor3 = Theme.danger
closeBtn.BackgroundTransparency = 0.3
closeBtn.Text = "X"
closeBtn.TextColor3 = Theme.text
closeBtn.TextSize = S(isMobile and 14 or 18)
closeBtn.Font = Enum.Font.SourceSans
closeBtn.AutoButtonColor = false
closeBtn.Parent = header
addCornerAndStroke(closeBtn, S(8))
closeBtn.MouseEnter:Connect(function()
    if not canExecuteInput("closeHover", "button") then return end
    playSound("hover")
    Services.Tween:Create(closeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.1, Rotation = 90}):Play()
end)
closeBtn.MouseLeave:Connect(function()
    Services.Tween:Create(closeBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.3, Rotation = 0}):Play()
end)
-- Content scrolling frame
local content = Instance.new("ScrollingFrame")
content.Name = "Content"
content.Size = UDim2.new(1, -S(10), 1, -S(isMobile and 45 or 55))
content.Position = UDim2.new(0, S(5), 0, S(isMobile and 45 or 55))
content.BackgroundColor3 = Theme.secondary
content.BackgroundTransparency = 0.8
content.BorderSizePixel = 0
content.ScrollBarThickness = S(isMobile and 2 or 3)
content.ScrollBarImageColor3 = Theme.accent
content.ScrollBarImageTransparency = 0.45
content.AutomaticCanvasSize = Enum.AutomaticSize.Y
content.Parent = mainFrame
addCornerAndStroke(content, S(12))
local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, S(6))
layout.Parent = content
-- Statistics Frame
local statsFrame = Instance.new("Frame")
statsFrame.Name = "StatsFrame"
statsFrame.Size = UDim2.new(1, -S(5), 0, S(isMobile and 200 or 220))
statsFrame.BackgroundColor3 = Theme.tertiary
statsFrame.BackgroundTransparency = 0.4
statsFrame.BorderSizePixel = 0
statsFrame.Parent = content
addCornerAndStroke(statsFrame, S(12), Theme.glassBorder, S(1))
local statsGradient = Instance.new("UIGradient")
statsGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Theme.tertiary), ColorSequenceKeypoint.new(1, Theme.secondary)}
statsGradient.Rotation = 90
statsGradient.Parent = statsFrame
local statLabels = {}
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -S(25), 0, S(25))
titleLabel.Position = UDim2.new(0, S(12), 0, S(10))
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Player Statistics & Analytics"
titleLabel.TextColor3 = Theme.accent
titleLabel.TextSize = S(isMobile and 14 or 18)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextYAlignment = Enum.TextYAlignment.Center
titleLabel.Parent = statsFrame
statLabels["title"] = titleLabel
local statPositions = {
    {name = "power", text = "Power: 0", x = 0, y = 40, width = 0.35, align = Enum.TextXAlignment.Left},
    {name = "kills", text = "Kill: 0", x = 0.35, y = 40, width = 0.30, align = Enum.TextXAlignment.Left},
    {name = "health", text = "Health: 100", x = 0.65, y = 40, width = 0.35, align = Enum.TextXAlignment.Right},
    {name = "fps", text = "FPS: 0", x = 0, y = 65, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "ping", text = "Ping: 0ms", x = 0.25, y = 65, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "tools", text = "Tools: 0", x = 0.75, y = 65, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "pph", text = "Power/hr: 0", x = 0, y = 90, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "session", text = "Session: +0", x = 0.5, y = 90, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "farmingTime", text = "Farm Time: 00:00", x = 0, y = 115, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "time", text = "Session: 00:00", x = 0.5, y = 115, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "eff", text = "Efficiency: Calculating...", x = 0, y = 140, width = 1, align = Enum.TextXAlignment.Left}
}
for _, stat in ipairs(statPositions) do
    local label = Instance.new("TextLabel")
    local xOffset = stat.align == Enum.TextXAlignment.Right and -S(12) or S(12)
    label.Size = UDim2.new(stat.width, -S(8), 0, S(22))
    label.Position = UDim2.new(stat.x, xOffset, 0, S(stat.y))
    label.BackgroundTransparency = 1
    label.Text = stat.text
    label.TextColor3 = Theme.text
    label.TextSize = S(isMobile and 10 or 12)
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = stat.align
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = statsFrame
    statLabels[stat.name] = label
end
-- Tool Functions
local function equipAll()
    local backpack, character = player:FindFirstChild("Backpack"), player.Character
    if not (backpack and character) then return false end
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            pcall(function() tool.Parent = character end)
        end
    end
    return true
end
local function updateToolCache(targetPlayer)
    targetPlayer = targetPlayer or player
    local currentTime = time()
    if targetPlayer == player then
        if currentTime - Data.lastUpdateTime < 0.1 then
            return #Data.toolCache
        end
        Data.lastUpdateTime = currentTime
        Data.toolCache = {}
    end
   
    local toolCount = 0
    local character, backpack = targetPlayer.Character, targetPlayer:FindFirstChild("Backpack")
    if character then
        for _, tool in pairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                if targetPlayer == player then
                    local handle = tool:FindFirstChild("Handle")
                    if handle then
                        Data.toolCache[#Data.toolCache + 1] = handle
                    end
                end
                toolCount = toolCount + 1
            end
        end
    end
    if backpack then
        for _, tool in pairs(backpack:GetChildren()) do
            if tool:IsA("Tool") then
                if targetPlayer == player then
                    local handle = tool:FindFirstChild("Handle")
                    if handle then
                        Data.toolCache[#Data.toolCache + 1] = handle
                    end
                end
                toolCount = toolCount + 1
            end
        end
    end
    return toolCount
end
local function getTools()
    if #Data.toolCache > 0 then return Data.toolCache end
    updateToolCache(player)
    if #Data.toolCache == 0 then
        local remote = workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent")
        if remote then
            local s = pcall(function() remote:FireServer() end)
            if s then
                task.wait(0.1)
                updateToolCache(player)
            end
        end
    end
    return Data.toolCache
end
local function findPlayer(name, sourcePlayer)
    if not name or name == "" or not sourcePlayer then return nil end
    local lowerName = name:lower()
    local allPlayers = Players:GetPlayers()
    if lowerName == "me" then
        return sourcePlayer
    end
    if lowerName == "all" then
        return allPlayers
    end
    if lowerName == "others" or lowerName == "other" then
        local targets = {}
        for _, p in ipairs(allPlayers) do
            if p ~= sourcePlayer then
                table.insert(targets, p)
            end
        end
        return targets
    end
    for _, p in ipairs(allPlayers) do
        if p.Name:lower() == lowerName or p.DisplayName:lower() == lowerName then
            return p
        end
    end
    for _, p in ipairs(allPlayers) do
        if p.Name:lower():find(lowerName, 1, true) or p.DisplayName:lower():find(lowerName, 1, true) then
            return p
        end
    end
    return nil
end
-- Combat Functions
local function killPlayer(t)
    if not t or not t.Character or not t.Character:FindFirstChildOfClass("Humanoid") then return false end
    if t == player then
        t.Character.Humanoid.Health = 0
        return true
    end
    local tools = getTools()
    if #tools == 0 then return false end
    local tool = #tools > 1 and tools[2] or tools[1]
    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            pcall(function() r:FireServer(t.Character.Humanoid, math.huge) end)
            return true
        end
    end
    return false
end
local function godPlayer(t)
    if not t or not t.Character or not t.Character:FindFirstChildOfClass("Humanoid") then return false end
    local tools = getTools()
    if #tools == 0 then return false end
    local tool = tools[1]
    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            pcall(function() r:FireServer(t.Character.Humanoid, -math.huge) end)
            return true
        end
    end
    return false
end
local function healPlayer(t)
    if not t or not t.Character then return false end
    local h = t.Character:FindFirstChildOfClass("Humanoid")
    if not h or h.Health >= h.MaxHealth then return false end
    local tools = getTools()
    if #tools == 0 then return false end
    local tool = tools[1]
    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            local healAmount = h.MaxHealth - h.Health
            pcall(function() r:FireServer(h, -healAmount) end)
            return true
        end
    end
    return false
end
local function damagePlayer(t, damageAmount)
    if not t or not t.Character then return false end
    local h = t.Character:FindFirstChildOfClass("Humanoid")
    if not h or h.Health <= 0 then return false end
    local tools = getTools()
    if #tools == 0 then return false end
    local tool = tools[1]
    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            pcall(function() r:FireServer(h, damageAmount) end)
            return true
        end
    end
    return false
end
local function killPlayerWithVerification(target)
    if not target or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or target.Character.Humanoid.Health <= 0 then
        return true
    end
    for i = 1, 3 do
        killPlayer(target)
        task.wait(0.1)
        if not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or target.Character.Humanoid.Health <= 0 then
            return true
        end
    end
    return false
end
local function healPlayerWithVerification(target)
    if not target or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") then
        return true
    end
    local h = target.Character.Humanoid
    if h.Health >= h.MaxHealth then return true end
    for i = 1, 4 do
        healPlayer(target)
        task.wait(0.1)
        if not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or h.Health >= h.MaxHealth then
            return true
        end
    end
    return false
end
local function godPlayerWithVerification(target)
    if not target or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") then
        return true
    end
    for i = 1, 4 do
        godPlayer(target)
        task.wait(0.1)
    end
    return true
end
local function damagePlayerWithVerification(target, damageAmount)
    if not target or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") then
        return false
    end
    local h = target.Character.Humanoid
    local initialHealth = h.Health
    if initialHealth <= 0 then return true end
    for i = 1, 4 do
        damagePlayer(target, damageAmount)
        task.wait(0.08)
        if not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or h.Health < initialHealth then
            return true
        end
    end
    return h.Health < initialHealth
end
local function executeSequentially(targetList, actionFunction, actionName)
    if #targetList == 0 then
        notification("No valid targets found.", 2, "warning")
        return
    end
    notification(string.format("Executing '%s' on %d player(s)...", actionName, #targetList), 2, "info")
    local successCount = 0
    for _, target in ipairs(targetList) do
        if target and target.Parent then
            local success, result = pcall(actionFunction, target)
            if success and result then
                successCount = successCount + 1
            end
        end
        task.wait(0.1)
    end
    notification(string.format("'%s' finished: %d/%d successful.", actionName, successCount, #targetList), 3, "success")
end
-- Reverse Damage System - IMPROVED
local reverseDmgConfig = {
    COOLDOWN = 0.15,
    CLEANUP_INTERVAL = 1.0,
    PROXIMITY_RANGE = 3
}
local attackerHistory = {}
local lastHealth = 0
local reverseDmgActive = false
local reverseDmgTools = {}

local function ensureReverseDmgTools()
    -- Load extra tool specifically for reverse damage
    if #reverseDmgTools == 0 then
        local remote = workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent")
        if remote then
            pcall(function() remote:FireServer() end)
            task.wait(0.1)
            reverseDmgTools = getTools()
        end
    end
    return reverseDmgTools
end

local function cleanupHistory()
    local currentTime = time()
    for attacker, data in pairs(attackerHistory) do
        if currentTime - data.timestamp > 10 then
            attackerHistory[attacker] = nil
        end
    end
end

local function retaliate(attacker)
    if not attacker or not attacker.Character or attacker == player or not reverseDmgActive then
        return false
    end
   
    local currentTime = time()
    local lastAttack = attackerHistory[attacker]
   
    if lastAttack and currentTime - lastAttack.timestamp < reverseDmgConfig.COOLDOWN then
        return false
    end
   
    attackerHistory[attacker] = {timestamp = currentTime}
   
    task.spawn(function()
        pcall(function()
            -- Use multiple tools for better retaliation
            local tools = ensureReverseDmgTools()
            for i = 1, 3 do
                for _, tool in ipairs(tools) do
                    if tool and tool.Parent and attacker.Character then
                        local targetHumanoid = attacker.Character:FindFirstChildOfClass("Humanoid")
                        if targetHumanoid and targetHumanoid.Health > 0 then
                            local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
                            if r then
                                pcall(function() r:FireServer(targetHumanoid, math.huge) end)
                            end
                        end
                    end
                end
                task.wait(0.05)
            end
        end)
    end)
   
    return true
end

local function setupReverseDamage()
    if Data.connections.reverseDmgMain then
        pcall(function() Data.connections.reverseDmgMain:Disconnect() end)
        Data.connections.reverseDmgMain = nil
    end
    if Data.connections.reverseDmgCleanup then
        if typeof(Data.connections.reverseDmgCleanup) == "thread" then
            task.cancel(Data.connections.reverseDmgCleanup)
        end
        Data.connections.reverseDmgCleanup = nil
    end
   
    attackerHistory = {}
    reverseDmgActive = State.reverseDmg
   
    if not State.reverseDmg or not player.Character then
        notification("Reverse Damage: OFF", 2, "info")
        return
    end
   
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
   
    lastHealth = humanoid.Health
    
    -- Load extra tools for reverse damage
    ensureReverseDmgTools()
   
    local lastCheck = 0
    Data.connections.reverseDmgMain = Services.Run.Heartbeat:Connect(function()
        if not reverseDmgActive or not State.reverseDmg or not player.Character then
            reverseDmgActive = false
            return
        end
       
        local currentTime = time()
        if currentTime - lastCheck < 0.1 then return end
        lastCheck = currentTime
       
        local currentHumanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not currentHumanoid then return end
       
        local currentHealth = currentHumanoid.Health
       
        -- Monitor health changes even in god mode
        if currentHealth < lastHealth or (State.godMode and currentHealth < currentHumanoid.MaxHealth) then
            local creator = currentHumanoid:FindFirstChild("creator")
            if creator and creator:IsA("ObjectValue") and creator.Value and creator.Value:IsA("Player") then
                local attacker = creator.Value
                if attacker ~= player then
                    retaliate(attacker)
                    notification("Retaliating against " .. attacker.DisplayName, 1, "combat")
                end
                task.spawn(function()
                    task.wait(0.05)
                    if creator and creator.Parent then
                        creator:Destroy()
                    end
                end)
            end
        end
       
        lastHealth = currentHealth
    end)
   
    Data.connections.reverseDmgCleanup = task.spawn(function()
        while State.reverseDmg and reverseDmgActive do
            task.wait(reverseDmgConfig.CLEANUP_INTERVAL)
            cleanupHistory()
        end
    end)
   
    notification("Reverse Damage: ACTIVE (Enhanced)", 2, "success")
    playSound("combat")
end
-- Loop Kill System
local function startLoopKill(targets, sourcePlayer)
    if State.loopKillActive then
        for _, conn in pairs(State.loopKillConnections) do
            if conn then conn:Disconnect() end
        end
        State.loopKillConnections = {}
    end
    if not targets then return end
    State.loopKillActive = true
    local targetList = type(targets) == "table" and targets or {targets}
    local connection = Services.Run.Heartbeat:Connect(function()
        if not State.loopKillActive then return end
        for _, target in pairs(targetList) do
            if target then
                task.spawn(killPlayer, target)
            end
        end
        task.wait(0.1)
    end)
    table.insert(State.loopKillConnections, connection)
    notification("Loop kill activated on " .. #targetList .. " targets", 3, "success")
end
local function stopLoopKill()
    if State.loopKillActive then
        for _, conn in pairs(State.loopKillConnections) do
            if conn then conn:Disconnect() end
        end
        State.loopKillConnections = {}
        State.loopKillActive = false
        notification("Loop kill deactivated", 2, "info")
    end
end
local function getAllToolHandles()
    local handles = {}
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
                table.insert(handles, tool.Handle)
            end
        end
    end
    if player.Backpack then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
                table.insert(handles, tool.Handle)
            end
        end
    end
    return handles
end
local function spamAttackWithAllMyTools(target)
    if not target or not target.Character or not target.Character:FindFirstChild("Humanoid") then
        return
    end
    local targetHumanoid = target.Character.Humanoid
    local allHandles = getAllToolHandles()
    for _, handle in ipairs(allHandles) do
        if handle then
            local r = handle:FindFirstChild("dmg") and handle.dmg:FindFirstChild("RemoteEvent")
            if r then
                pcall(function() r:FireServer(targetHumanoid, math.huge) end)
            end
        end
    end
end
local stopKillFarm
local function startKillFarm(target)
    if State.killFarmActive then stopKillFarm() end
    if not target or type(target) == "table" then
        notification("Invalid target for killfarm.", 2, "error")
        return
    end
    State.killFarmActive = true
    State.killFarmTarget = target
    notification("Multi-tool kill farm activated on " .. target.DisplayName, 3, "success")
    State.killFarmConnection = Services.Run.Heartbeat:Connect(function()
        if not State.killFarmActive then return end
        local currentTarget = State.killFarmTarget
       
        if not currentTarget or not currentTarget.Parent then
            stopKillFarm()
            notification("Kill farm target lost. Deactivating.", 2, "warning")
            return
        end
       
        spamAttackWithAllMyTools(currentTarget)
        task.wait(0.1)
    end)
end
stopKillFarm = function()
    if State.killFarmActive then
        State.killFarmActive = false
        State.killFarmTarget = nil
        if State.killFarmConnection then
            State.killFarmConnection:Disconnect()
            State.killFarmConnection = nil
        end
        notification("Kill farm deactivated", 2, "info")
    end
end
-- Farm function with speed parameter
local function farm(speed)
    if not player.Character then return end
    
    -- Always ensure we have tools before farming
    local tools = getTools()
    if #tools == 0 then
        -- Try to load tools if we don't have any
        local remote = workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent")
        if remote then
            pcall(function() remote:FireServer() end)
            task.wait(0.15)
            tools = getTools()
        end
    end
    
    -- Farm with all available tools
    for _, h in pairs(tools) do
        if h and h.Parent then
            local r = h:FindFirstChild("up") and h.up:FindFirstChild("RemoteEvent")
            if r then
                for i = 1, speed do
                    pcall(function() r:FireServer() end)
                end
            end
        end
    end
end
local function watchPlayer(targetName)
    local target = findPlayer(targetName, player)
    if not target or type(target) == "table" then
        notification("Player not found.", 2, "error")
        return
    end
    State.watchingPlayer = target
    notification("Now watching " .. target.DisplayName, 3, "success")
end
-- Protection System - IMPROVED
local protectionTools = {}

local function ensureProtectionTools()
    -- Load extra tools specifically for protection
    if #protectionTools == 0 then
        local remote = workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent")
        if remote then
            pcall(function() remote:FireServer() end)
            task.wait(0.1)
            protectionTools = getTools()
        end
    end
    return protectionTools
end

local function protectPlayer(targetName)
    local target = findPlayer(targetName, player)
    if not target or type(target) == "table" then
        notification("Player not found: " .. tostring(targetName), 2, "error")
        return
    end
    if Data.protectionConnection then Data.protectionConnection:Disconnect() end
    if Data.protectedPlayerConnection then Data.protectedPlayerConnection:Disconnect() end
    if Data.protectionHeartbeat then Data.protectionHeartbeat:Disconnect() end
    if Data.protectionCleanup then task.cancel(Data.protectionCleanup) end
    State.protectedPlayer = target
    State.protectionActive = true
    notification("Enhanced Protection enabled for " .. target.DisplayName, 3, "success")
    playSound("shield")
   
    -- Load extra tools for protection
    ensureProtectionTools()
   
    local protectionAttackerHistory = {}
    local protectionLastHealth = 0
   
    local function cleanupProtectionHistory()
        local currentTime = time()
        for attacker, data in pairs(protectionAttackerHistory) do
            if currentTime - data.timestamp > 8 then
                protectionAttackerHistory[attacker] = nil
            end
        end
    end
   
    local function retaliateForProtected(attacker, method)
        if not attacker or not attacker.Character then return false end
        local currentTime = time()
        local lastAttack = protectionAttackerHistory[attacker]
       
        if lastAttack and currentTime - lastAttack.timestamp < 0.15 then
            return false
        end
        protectionAttackerHistory[attacker] = {timestamp = currentTime}
       
        task.spawn(function()
            local tools = ensureProtectionTools()
            for i = 1, 5 do -- More aggressive retaliation
                for _, tool in ipairs(tools) do
                    if tool and tool.Parent and attacker.Character then
                        local targetHumanoid = attacker.Character:FindFirstChildOfClass("Humanoid")
                        if targetHumanoid and targetHumanoid.Health > 0 then
                            local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
                            if r then
                                pcall(function() r:FireServer(targetHumanoid, math.huge) end)
                            end
                        end
                    end
                end
                task.wait(0.05)
            end
        end)
        playSound("combat")
        notification("Protected " .. target.DisplayName .. "! Attacking " .. attacker.DisplayName .. " (" .. method .. ")", 2, "combat")
        return true
    end
   
    local function setupProtection(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        protectionLastHealth = humanoid.Health
        Data.protectionConnection = humanoid.ChildAdded:Connect(function(child)
            if not State.protectionActive or child.Name ~= "creator" then return end
            if child:IsA("ObjectValue") and child.Value and child.Value:IsA("Player") then
                local attacker = child.Value
                if attacker ~= target and attacker ~= player then
                    task.spawn(retaliateForProtected, attacker, "Direct Hit")
                end
                task.spawn(function()
                    task.wait(0.05)
                    if child and child.Parent then child:Destroy() end
                end)
            end
        end)
       
        local lastCheck = 0
        Data.protectionHeartbeat = Services.Run.Heartbeat:Connect(function()
            if not State.protectionActive or State.protectedPlayer ~= target then return end
            if not target.Character then return end
           
            local currentTime = time()
            if currentTime - lastCheck < 0.05 then return end
            lastCheck = currentTime
            local currentHumanoid = target.Character:FindFirstChildOfClass("Humanoid")
            if not currentHumanoid then return end
            local currentHealth = currentHumanoid.Health
           
            if currentHealth ~= protectionLastHealth and currentHealth < protectionLastHealth then
                local nearbyPlayers = {}
                for _, p in pairs(Players:GetPlayers()) do
                    if p ~= target and p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (p.Character.HumanoidRootPart.Position - target.Character.HumanoidRootPart.Position).Magnitude
                        if distance <= 40 then
                            table.insert(nearbyPlayers, {player = p, distance = distance})
                        end
                    end
                end
                table.sort(nearbyPlayers, function(a, b) return a.distance < b.distance end)
                if #nearbyPlayers > 0 then
                    task.spawn(retaliateForProtected, nearbyPlayers[1].player, "Health Drop")
                end
            end
           
            protectionLastHealth = currentHealth
        end)
       
        Data.protectionCleanup = task.spawn(function()
            while State.protectionActive do
                task.wait(1.0)
                cleanupProtectionHistory()
            end
        end)
    end
   
    if target.Character then setupProtection(target.Character) end
    Data.protectedPlayerConnection = target.CharacterAdded:Connect(function(character)
        task.wait(1)
        setupProtection(character)
    end)
end
local function stopProtection()
    if Data.protectionConnection then Data.protectionConnection:Disconnect() end
    if Data.protectedPlayerConnection then Data.protectedPlayerConnection:Disconnect() end
    if Data.protectionHeartbeat then Data.protectionHeartbeat:Disconnect() end
    if Data.protectionCleanup then task.cancel(Data.protectionCleanup) end
    State.protectedPlayer = nil
    State.protectionActive = false
    notification("Protection deactivated", 2, "info")
end
local function toggleSpeedHack(enabled, speed)
    if Data.speedConnections then
        for _, conn in pairs(Data.speedConnections) do
            if conn then conn:Disconnect() end
        end
        Data.speedConnections = {}
    end
    State.speedHack = enabled
    if enabled and player.Character then
        local h = player.Character:FindFirstChildOfClass("Humanoid")
        if h then
            h.WalkSpeed = speed or 50
            table.insert(Data.speedConnections, h:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                if State.speedHack then
                    h.WalkSpeed = speed or 50
                end
            end))
        end
    elseif player.Character then
        local h = player.Character:FindFirstChildOfClass("Humanoid")
        if h then
            h.WalkSpeed = Config.walkSpeed
        end
    end
end
local powerHistory = {}
local leaderstatsCache = {}
local function updateStats(deltaTime)
    local targetPlayer = State.watchingPlayer or player
    local isWatching = (targetPlayer ~= player)
    statLabels.title.Text = isWatching and ("Watching: " .. targetPlayer.DisplayName) or "Player Statistics & Analytics"
    statLabels.title.TextColor3 = isWatching and Theme.warning or Theme.accent
   
    local ls = targetPlayer:FindFirstChild("leaderstats")
    local target_power, target_kills = 0, 0
    if ls then
        if not leaderstatsCache[targetPlayer] then leaderstatsCache[targetPlayer] = {} end
        local cache = leaderstatsCache[targetPlayer]
       
        if not cache.power then
            for _, n in ipairs({"Power", "Strength", "Energy", "Points", "Coins"}) do
                local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
                if s then
                    cache.power = s
                    break
                end
            end
        end
        if cache.power then target_power = tonumber(cache.power.Value) or 0 end
       
        if not cache.kills then
            for _, n in ipairs({"Kills", "KOs", "Eliminations"}) do
                local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
                if s then
                    cache.kills = s
                    break
                end
            end
        end
        if cache.kills then target_kills = tonumber(cache.kills.Value) or 0 end
    end
   
    local target_health, target_maxHealth = 0, 100
    if targetPlayer.Character and targetPlayer.Character:FindFirstChildOfClass("Humanoid") then
        local h = targetPlayer.Character.Humanoid
        target_health, target_maxHealth = math.floor(h.Health), math.floor(h.MaxHealth)
    end
   
    local tool_count = updateToolCache(targetPlayer)
   
    statLabels.power.Text = "Power: " .. formatNumber(target_power or (isWatching and 0 or Stats.power))
    statLabels.kills.Text = "Kill: " .. formatNumber(target_kills or (isWatching and 0 or Stats.kills))
    statLabels.tools.Text = "Tools: " .. tool_count
    statLabels.tools.TextColor3 = tool_count > 0 and Theme.success or Theme.danger
   
    if target_health then
        if not isWatching and State.godMode then
            statLabels.health.Text = "Health: âˆž"
            statLabels.health.TextColor3 = Theme.glow
        else
            local hp = math.floor((target_health / target_maxHealth) * 100)
            statLabels.health.Text = "Health: " .. formatNumber(target_health) .. "/" .. formatNumber(target_maxHealth)
            statLabels.health.TextColor3 = hp <= 25 and Theme.danger or hp <= 50 and Theme.warning or hp <= 75 and Theme.text or Theme.success
        end
    else
        statLabels.health.Text = "Health: N/A"
        statLabels.health.TextColor3 = Theme.textMuted
    end
   
    local currentTime = time()
    local sessionTime = currentTime - Stats.sessionStartTime
    if not isWatching then
        Stats.power = target_power or Stats.power
        Stats.kills = target_kills or Stats.kills
    end
   
    if State.fastFarm or State.slowFarm then
        if not isWatching then
            Stats.powerGainedFarming = (Stats.power or 0) - (Stats.farmStartPower or 0)
        end
       
        if #powerHistory == 0 or currentTime - powerHistory[#powerHistory].time > 1 then
            table.insert(powerHistory, {time = currentTime, power = Stats.power})
            if #powerHistory > 8 then table.remove(powerHistory, 1) end
        end
       
        if #powerHistory >= 2 then
            local td = powerHistory[#powerHistory].time - powerHistory[1].time
            local pd = powerHistory[#powerHistory].power - powerHistory[1].power
            if td > 0 then
                Stats.powerPerSecond = pd / td
                Stats.powerPerHour = Stats.powerPerSecond * 3600
            end
        end
       
        Stats.farmingTime = Stats.farmingTime + deltaTime
    else
        Stats.powerPerSecond = 0
        Stats.powerPerHour = 0
    end
   
    statLabels.pph.Text = "Power/hr: " .. formatNumber(Stats.powerPerHour)
    statLabels.session.Text = "Session: +" .. formatNumber(Stats.powerGainedFarming)
    statLabels.fps.Text = "FPS: " .. Performance.fps
    statLabels.ping.Text = "Ping: " .. (Performance.ping > 0 and Performance.ping .. "ms" or "N/A")
    statLabels.farmingTime.Text = "Farm Time: " .. formatTimeMinutes(Stats.farmingTime)
    statLabels.time.Text = "Session: " .. formatTimeMinutes(sessionTime)
   
    local eff, ec = "Calculating...", Theme.accent
    if State.fastFarm or State.slowFarm then
        local farmSpeed = State.fastFarm and Config.speed * FARM_CONFIG.FAST_MULTIPLIER or Config.speed * FARM_CONFIG.SLOW_MULTIPLIER
       
        if Stats.powerPerHour >= 1e6 then
            eff, ec = "Exceptional", Theme.glow
        elseif Stats.powerPerHour >= 5e5 then
            eff, ec = "Strong", Theme.success
        elseif Stats.powerPerHour >= 1e5 then
            eff, ec = "Good", Theme.success
        else
            eff, ec = "Active", Theme.warning
        end
       
        eff = eff .. " (Rate: " .. string.format("%.2f", farmSpeed) .. " | " .. formatNumber(Stats.powerPerHour) .. "/hr)"
    else
        eff, ec = "Farming disabled", Theme.danger
    end
    statLabels.eff.Text = "Efficiency: " .. eff
    statLabels.eff.TextColor3 = ec
end
local function setLocalGodMode(enabled)
    if State.godMode == enabled then return end
    State.godMode = enabled
    local t = Data.uiElements.godModeToggle
    if t then
        t.Text = enabled and "ON" or "OFF"
        Services.Tween:Create(t, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {BackgroundColor3 = enabled and Theme.success or Theme.danger}):Play()
    end
    if State.coroutines.godMode then
        task.cancel(State.coroutines.godMode)
        State.coroutines.godMode = nil
    end
    notification("God mode " .. (enabled and "activated" or "deactivated"), 2, enabled and "success" or "info")
    if enabled then
        State.coroutines.godMode = task.spawn(function()
            while State.godMode and player.Character do
                godPlayer(player)
                task.wait(0.1)
            end
        end)
    end
end
-- COMMANDS (COMPLETE LIST)
local showCommandsUI
local cmds = {
    {"cmds", "Display the list of commands", function() if showCommandsUI then showCommandsUI() end end},
    {"admin [player/all/others]", "Grant command admin to players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found.", 2, "error")
            return
        end
       
        if type(targets) == "table" then
            local count = 0
            for _, p in pairs(targets) do
                if p ~= player and not table.find(Data.adminPlayers, p.Name) then
                    table.insert(Data.adminPlayers, p.Name)
                    count = count + 1
                end
            end
            notification("Admin granted to " .. count .. " players", 3, "success")
        else
            if targets ~= player and not table.find(Data.adminPlayers, targets.Name) then
                table.insert(Data.adminPlayers, targets.Name)
                notification("Admin granted to " .. targets.DisplayName, 3, "success")
            elseif targets == player then
                notification("You are the owner.", 2, "info")
            else
                notification(targets.DisplayName .. " is already an admin.", 2, "info")
            end
        end
    end},
    {"unadmin [player/all/others]", "Revoke command admin from players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found.", 2, "error")
            return
        end
       
        local function revokeAdmin(targetPlayer)
            if targetPlayer == player then return false end
            local f
            for i, n in ipairs(Data.adminPlayers) do
                if n == targetPlayer.Name then
                    f = i
                    break
                end
            end
            if f then
                table.remove(Data.adminPlayers, f)
                return true
            end
            return false
        end
       
        if type(targets) == "table" then
            local count = 0
            for _, p in pairs(targets) do
                if revokeAdmin(p) then
                    count = count + 1
                end
            end
            notification("Admin revoked from " .. count .. " players", 3, "success")
        else
            if revokeAdmin(targets) then
                notification("Admin revoked from " .. targets.DisplayName, 3, "success")
            else
                notification("Could not revoke admin.", 2, "error")
            end
        end
    end},
    {"tp/to [player]", "Teleport to a player", function(args, sourcePlayer)
        local t = findPlayer(args[2], sourcePlayer)
        if t and type(t) ~= "table" and t.Character and sourcePlayer.Character then
            sourcePlayer.Character.HumanoidRootPart.CFrame = t.Character.HumanoidRootPart.CFrame
            notification("Teleported to " .. t.DisplayName, 2, "success")
        else
            notification("Player not found.", 2, "error")
        end
    end},
    {"dupe [amount]", "Duplicate tools", function(args, sourcePlayer)
        local amount = tonumber(args[2])
        if not amount or amount <= 0 or amount > 750 then
            notification("Usage: ;dupe [1-750]", 4, "warning")
            return
        end
       
        local remote = workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent")
        if not remote then
            notification("Duplication unavailable.", 3, "error")
            return
        end
       
        if sourcePlayer == player then
            task.spawn(function()
                notification(string.format("Duplicating %d items...", amount), 3, "info")
                for i = 1, amount do
                    equipAll()
                    remote:FireServer()
                    task.wait(0.8)
                end
                equipAll()
                notification("Duplication finished.", 5, "success")
            end)
            return
        end
       
        task.spawn(function()
            local ownerChar, adminChar = player.Character, sourcePlayer.Character
            if not (ownerChar and ownerChar:FindFirstChild("HumanoidRootPart")) then
                notification("Your character is missing.", 3, "error")
                return
            end
            if not (adminChar and adminChar:FindFirstChild("HumanoidRootPart")) then
                notification(string.format("%s's character is missing.", sourcePlayer.DisplayName), 3, "error")
                return
            end
           
            notification(string.format("%s requested %d tools. Dropping...", sourcePlayer.DisplayName, amount), 3, "info")
            local originalCFrame = ownerChar.HumanoidRootPart.CFrame
            ownerChar.HumanoidRootPart.CFrame = adminChar.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            task.wait(0.2)
           
            local existingTools = {}
            for _, c in ipairs({player.Character, player.Backpack}) do
                if c then
                    for _, t in ipairs(c:GetChildren()) do
                        if t:IsA("Tool") then
                            existingTools[t] = true
                        end
                    end
                end
            end
           
            for i = 1, amount do
                equipAll()
                remote:FireServer()
                task.wait(0.1)
            end
           
            equipAll()
            task.wait(0.1)
           
            local newTools = {}
            for _, c in ipairs({player.Character, player.Backpack}) do
                if c then
                    for _, t in ipairs(c:GetChildren()) do
                        if t:IsA("Tool") and not existingTools[t] then
                            table.insert(newTools, t)
                        end
                    end
                end
            end
           
            if #newTools == 0 then
                notification("Failed to generate tools.", 4, "error")
                ownerChar.HumanoidRootPart.CFrame = originalCFrame
                return
            end
           
            local droppedCount = 0
            for _, tool in ipairs(newTools) do
                tool.Parent = workspace
                droppedCount = droppedCount + 1
            end
           
            ownerChar.HumanoidRootPart.CFrame = originalCFrame
            notification(string.format("Dropped %d tools for %s.", droppedCount, sourcePlayer.DisplayName), 5, "success")
        end)
    end},
    {"kill [player/all/others/me]", "Reliably eliminate players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found.", 2, "error")
            return
        end
       
        local targetList = (type(targets) == "table") and targets or {targets}
        task.spawn(executeSequentially, targetList, killPlayerWithVerification, "kill")
    end},
    {"killfarm [player]", "Activate aggressive kill farming on target", function(args, sourcePlayer)
        if not args[2] then
            notification("Usage: ;killfarm [player name]", 3, "warning")
            return
        end
        local target = findPlayer(args[2], sourcePlayer)
        if target and type(target) ~= "table" then
            startKillFarm(target)
        else
            notification("Player not found: " .. args[2], 2, "error")
        end
    end},
    {"stopkillfarm", "Stops the killfarm loop", stopKillFarm},
    {"rejoin/rj", "Rejoins the current server", function()
        notification("Rejoining server...", 2, "info")
        local success, err = pcall(function()
            Services.Teleport:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
        end)
        if not success then
            notification("Rejoin failed: " .. err, 4, "error")
        end
    end},
    {"dmg [player/all/others] [percent]", "Reliably apply damage to players", function(args, sourcePlayer)
        local targetName, damagePercent = args[2], tonumber(args[3])
        if not targetName or not damagePercent or damagePercent <= 0 then
            notification("Usage: ;dmg [target] [percent > 0]", 3, "warning")
            return
        end
        local targets = findPlayer(targetName, sourcePlayer)
        if not targets then
            notification("Target not found.", 2, "error")
            return
        end
        local targetList = (type(targets) == "table") and targets or {targets}
        local actionName = string.format("damage (%.0f%%)", damagePercent)
        task.spawn(function()
            if #targetList == 0 then
                notification("No valid targets found.", 2, "warning")
                return
            end
            notification(string.format("Executing '%s' on %d player(s)...", actionName, #targetList), 2, "info")
            local successCount = 0
           
            for _, target in ipairs(targetList) do
                if target and target.Parent then
                    local success, result = pcall(function()
                        if not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") then
                            return false
                        end
                        local h = target.Character.Humanoid
                        local damageAmount = (damagePercent / 100) * h.MaxHealth
                        return damagePlayerWithVerification(target, damageAmount)
                    end)
                    if success and result then
                        successCount = successCount + 1
                    end
                end
                task.wait(0.15)
            end
           
            notification(string.format("'%s' finished: %d/%d successful.", actionName, successCount, #targetList), 3, "success")
        end)
    end},
    {"loopkill [player/all/others/me]", "Continuously eliminate target(s)", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if targets then
            startLoopKill(targets, sourcePlayer)
        else
            notification("Player not found.", 2, "error")
        end
    end},
    {"unloopkill/stoploopkill", "Deactivate loop kill", function() stopLoopKill() end},
    {"god [player/all/others/me]", "Reliably activate god mode", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found.", 2, "error")
            return
        end
       
        if targets == player then
            setLocalGodMode(true)
            return
        end
       
        local targetList = (type(targets) == "table") and targets or {targets}
        task.spawn(executeSequentially, targetList, godPlayerWithVerification, "god")
    end},
    {"heal [player/all/others/me]", "Reliably restore health for players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found.", 2, "error")
            return
        end
       
        local targetList = (type(targets) == "table") and targets or {targets}
        task.spawn(executeSequentially, targetList, healPlayerWithVerification, "heal")
    end},
    {"protect [player]", "Protect a player from attackers", function(args, sourcePlayer)
        if not args[2] then
            notification("Usage: ;protect [player name]", 3, "warning")
            return
        end
        protectPlayer(args[2])
    end},
    {"unprotect", "Deactivate protection", function() stopProtection() end},
    {"reversedmg", "Toggle instant retaliation on attackers", function()
        State.reverseDmg = not State.reverseDmg
        if State.reverseDmg then
            setupReverseDamage()
        else
            if Data.connections.reverseDmgMain then
                Data.connections.reverseDmgMain:Disconnect()
                Data.connections.reverseDmgMain = nil
            end
            if Data.connections.reverseDmgCleanup then
                if type(Data.connections.reverseDmgCleanup) == "table" then
                    task.cancel(Data.connections.reverseDmgCleanup)
                else
                    pcall(function() Data.connections.reverseDmgCleanup:Disconnect() end)
                end
                Data.connections.reverseDmgCleanup = nil
            end
            attackerHistory = {}
            notification("Reverse Damage: OFF", 2, "info")
        end
    end},
    {"fly", "Toggle flight mode", function(args, sourcePlayer)
        if sourcePlayer ~= player then
            notification("Owner only.", 2, "error")
            return
        end
       
        State.flying = not State.flying
        notification("Flight " .. (State.flying and "ON" or "OFF"), 2, "info")
       
        if Data.flyConnection then
            Data.flyConnection:Disconnect()
            Data.flyConnection = nil
        end
        if Data.charDiedFlyConnection then
            Data.charDiedFlyConnection:Disconnect()
            Data.charDiedFlyConnection = nil
        end
        if Data.flyObjects then
            for _, v in pairs(Data.flyObjects) do
                if v and v.Parent then
                    v:Destroy()
                end
            end
            Data.flyObjects = {}
        end
        if player.Character then
            local h = player.Character:FindFirstChildOfClass("Humanoid")
            if h then
                h.PlatformStand = false
            end
        end
       
        if not State.flying then return end
       
        local char = player.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then
            notification("Cannot fly without character.", 2, "error")
            State.flying = false
            return
        end
       
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        local rootPart = char.HumanoidRootPart
        humanoid.PlatformStand = true
       
        local bv = Instance.new("BodyVelocity", rootPart)
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new()
       
        local bg = Instance.new("BodyGyro", rootPart)
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.D = 100
        bg.P = 10000
        bg.CFrame = rootPart.CFrame
       
        Data.flyObjects = {bv = bv, bg = bg}
       
        Data.flyConnection = Services.Run.Heartbeat:Connect(function()
            if not State.flying or not Data.flyObjects.bv or not Data.flyObjects.bv.Parent then
                if Data.flyConnection then
                    Data.flyConnection:Disconnect()
                    Data.flyConnection = nil
                end
                return
            end
           
            local cam = workspace.CurrentCamera
            local moveVector = Vector3.new()
           
            if Services.UIS:IsKeyDown(Enum.KeyCode.W) then
                moveVector = moveVector + cam.CFrame.LookVector
            end
            if Services.UIS:IsKeyDown(Enum.KeyCode.S) then
                moveVector = moveVector - cam.CFrame.LookVector
            end
            if Services.UIS:IsKeyDown(Enum.KeyCode.A) then
                moveVector = moveVector - cam.CFrame.RightVector
            end
            if Services.UIS:IsKeyDown(Enum.KeyCode.D) then
                moveVector = moveVector + cam.CFrame.RightVector
            end
            if Services.UIS:IsKeyDown(Enum.KeyCode.Space) then
                moveVector = moveVector + Vector3.new(0, 1, 0)
            end
            if Services.UIS:IsKeyDown(Enum.KeyCode.LeftShift) then
                moveVector = moveVector - Vector3.new(0, 1, 0)
            end
           
            Data.flyObjects.bv.Velocity = moveVector.Magnitude > 0 and moveVector.Unit * Config.flySpeed or Vector3.new()
            Data.flyObjects.bg.CFrame = cam.CFrame
        end)
       
        Data.charDiedFlyConnection = humanoid.Died:Connect(function()
            State.flying = false
            notification("Flight OFF (death).", 2, "info")
            if Data.flyConnection then
                Data.flyConnection:Disconnect()
                Data.flyConnection = nil
            end
            if Data.charDiedFlyConnection then
                Data.charDiedFlyConnection:Disconnect()
                Data.charDiedFlyConnection = nil
            end
        end)
    end},
    {"unfly", "Deactivate flight", function(args, sourcePlayer)
        if sourcePlayer ~= player then return end
       
        if State.flying then
            State.flying = false
            if Data.flyConnection then
                Data.flyConnection:Disconnect()
                Data.flyConnection = nil
            end
            if Data.charDiedFlyConnection then
                Data.charDiedFlyConnection:Disconnect()
                Data.charDiedFlyConnection = nil
            end
            if Data.flyObjects then
                for _, v in pairs(Data.flyObjects) do
                    if v and v.Parent then
                        v:Destroy()
                    end
                end
                Data.flyObjects = {}
            end
            if player.Character then
                local h = player.Character:FindFirstChildOfClass("Humanoid")
                if h then
                    h.PlatformStand = false
                end
            end
            notification("Flight OFF", 2, "info")
        else
            notification("Flight is already OFF", 2, "info")
        end
    end},
    {"noclip", "Toggle no-clip mode", function(args, sourcePlayer)
        if sourcePlayer ~= player then
            notification("Noclip is owner-only.", 2, "error")
            return
        end
       
        State.noclip = not State.noclip
        notification("Noclip " .. (State.noclip and "ON" or "OFF"), 2, "info")
       
        if State.noclip then
            Data.noclipConnection = Services.Run.Stepped:Connect(function()
                if player.Character then
                    for _, p in pairs(player.Character:GetDescendants()) do
                        if p:IsA("BasePart") and p.CanCollide then
                            p.CanCollide = false
                        end
                    end
                end
            end)
        else
            if Data.noclipConnection then
                Data.noclipConnection:Disconnect()
                Data.noclipConnection = nil
            end
        end
    end},
    {"unnoclip", "Deactivate no-clip", function(args, sourcePlayer)
        if sourcePlayer ~= player then return end
       
        if State.noclip then
            State.noclip = false
            if Data.noclipConnection then
                Data.noclipConnection:Disconnect()
                Data.noclipConnection = nil
            end
            notification("Noclip OFF", 2, "info")
        else
            notification("Noclip is already OFF", 2, "info")
        end
    end},
    {"speed/ws [num]", "Set walking speed", function(args, sourcePlayer)
        if sourcePlayer ~= player then
            notification("Speed is owner-only.", 2, "error")
            return
        end
       
        local s = tonumber(args[2]) or 16
        toggleSpeedHack(s ~= 16, s)
        notification("Walkspeed set to " .. s, 2, "success")
    end},
    {"watch [player]", "Monitor a player's statistics", function(args, sourcePlayer)
        if not args[2] then
            notification("Usage: ;watch [player]", 3, "warning")
            return
        end
        watchPlayer(args[2])
    end},
    {"unwatch", "Stop monitoring player", function()
        if State.watchingPlayer then
            State.watchingPlayer = nil
            notification("Stopped watching", 2, "info")
        else
            notification("Not watching anyone.", 2, "info")
        end
    end},
    {"reset", "Reset your character", function(args, sourcePlayer)
        if sourcePlayer.Character then
            local h = sourcePlayer.Character:FindFirstChildOfClass("Humanoid")
            if h then
                h.Health = 0
            end
        end
    end}
}
local function executeCmd(cmd, sourcePlayer)
    sourcePlayer = sourcePlayer or player
    if not canExecuteInput("executeCmd", "command") or not cmd or cmd == "" then return end
    if cmd:sub(1, 1) == Config.commandPrefix then
        cmd = cmd:sub(2)
    end
    local args = {}
    for a in cmd:gmatch("%S+") do
        table.insert(args, a)
    end
    if #args == 0 then return end
    local cmdName = args[1]:lower()
    for _, c in ipairs(cmds) do
        local cmdPattern = c[1]:split(" ")[1]
        local found = false
       
        if cmdPattern:find("/") then
            for alt in cmdPattern:gmatch("[^/]+") do
                if alt == cmdName then
                    found = true
                    break
                end
            end
        elseif cmdPattern == cmdName then
            found = true
        end
       
        if found then
            playSound("click")
            pcall(c[3], args, sourcePlayer)
            return
        end
    end
    notification("Unknown command: " .. cmdName, 2, "error")
end
-- UI Creation Functions
local function createToggle(text, callback, inputConfig)
    local hasInput = inputConfig and inputConfig.key
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1, -S(5), 0, S(isMobile and 40 or 50))
    f.BackgroundColor3 = Theme.tertiary
    f.BackgroundTransparency = 0.5
    f.Parent = content
    addCornerAndStroke(f, S(10), Theme.glassBorder, S(1))
   
    local l = Instance.new("TextLabel")
    l.Size = UDim2.new(1, hasInput and -S(isMobile and 100 or 120) or -S(isMobile and 60 or 70), 1, 0)
    l.Position = UDim2.new(0, S(14), 0, 0)
    l.BackgroundTransparency = 1
    l.Text = text
    l.TextColor3 = Theme.text
    l.TextSize = S(isMobile and 10 or 12)
    l.Font = Enum.Font.Gotham
    l.TextXAlignment = Enum.TextXAlignment.Left
    l.Parent = f
   
    local si
    if hasInput then
        si = Instance.new("TextBox")
        si.Size = UDim2.new(0, S(isMobile and 30 or 40), 0, S(isMobile and 20 or 25))
        si.Position = UDim2.new(1, -S(isMobile and 100 or 115), 0.5, -S(isMobile and 10 or 12.5))
        si.BackgroundColor3 = Theme.secondary
        si.BackgroundTransparency = 0.5
        si.Text = tostring(Config[inputConfig.key])
        si.TextColor3 = Theme.text
        si.TextSize = S(isMobile and 8 or 10)
        si.Font = Enum.Font.Gotham
        si.Parent = f
        addCornerAndStroke(si, S(5))
       
        si.FocusLost:Connect(function(enter)
            local n = tonumber(si.Text)
            local min = inputConfig.min or 1
            local max = inputConfig.max or 100
           
            if n and n >= min and n <= max then
                Config[inputConfig.key] = n
                notification(text .. " set to " .. n, 2, "success")
            else
                si.Text = tostring(Config[inputConfig.key])
                notification("Invalid value (" .. min .. "-" .. max .. ").", 2, "warning")
            end
        end)
    end
   
    local t = Instance.new("TextButton")
    t.Size = UDim2.new(0, S(isMobile and 45 or 55), 0, S(isMobile and 25 or 30))
    t.Position = UDim2.new(1, -S(isMobile and 55 or 65), 0.5, -S(isMobile and 12.5 or 15))
    t.BackgroundColor3 = Theme.danger
    t.BackgroundTransparency = 0.3
    t.Text = "OFF"
    t.TextColor3 = Theme.text
    t.TextSize = S(isMobile and 8 or 10)
    t.Font = Enum.Font.GothamBold
    t.AutoButtonColor = false
    t.Parent = f
    addCornerAndStroke(t, S(6))
   
    local enabled = false
    t.MouseEnter:Connect(function()
        if not canExecuteInput("toggleHover" .. text, "button") then return end
        playSound("hover")
        Services.Tween:Create(t, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.1}):Play()
    end)
    t.MouseLeave:Connect(function()
        Services.Tween:Create(t, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.3}):Play()
    end)
    t.MouseButton1Click:Connect(function()
        if not canExecuteInput("toggle" .. text, "button") then return end
        enabled = not enabled
        playSound("click")
        t.Text = enabled and "ON" or "OFF"
        Services.Tween:Create(t, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
            BackgroundColor3 = enabled and Theme.success or Theme.danger,
            Rotation = enabled and 180 or 0
        }):Play()
       
        if callback and typeof(callback) == "function" then
            callback(enabled, t)
        end
    end)
    return f, t, si
end
local function createButton(text, callback, color)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, -S(5), 0, S(isMobile and 35 or 45))
    b.BackgroundColor3 = color or Theme.tertiary
    b.BackgroundTransparency = 0.5
    b.Text = text
    b.TextColor3 = Theme.text
    b.TextSize = S(isMobile and 10 or 12)
    b.Font = Enum.Font.GothamBold
    b.AutoButtonColor = false
    b.Parent = content
    addCornerAndStroke(b, S(10), Theme.glassBorder, S(1))
   
    local btnGrad = Instance.new("UIGradient")
    btnGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, color or Theme.tertiary),
        ColorSequenceKeypoint.new(1, (color or Theme.tertiary):Lerp(Color3.new(0,0,0), 0.1))
    }
    btnGrad.Rotation = 90
    btnGrad.Parent = b
   
    b.MouseEnter:Connect(function()
        if not canExecuteInput("btnHover" .. text, "button") then return end
        playSound("hover")
        Services.Tween:Create(b, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.3}):Play()
        Services.Tween:Create(btnGrad, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Rotation = 270}):Play()
    end)
    b.MouseLeave:Connect(function()
        Services.Tween:Create(b, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.5}):Play()
        Services.Tween:Create(btnGrad, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Rotation = 90}):Play()
    end)
    b.MouseButton1Click:Connect(function()
        if not canExecuteInput("btn" .. text, "button") then return end
        playSound("click")
        Services.Tween:Create(b, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
            Size = UDim2.new(1, -S(8), 0, S(isMobile and 32 or 42))
        }):Play()
        task.wait(0.1)
        Services.Tween:Create(b, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(1, -S(5), 0, S(isMobile and 35 or 45))
        }):Play()
        callback()
    end)
    return b
end
-- Commands UI
showCommandsUI = function()
    if screenGui:FindFirstChild("CommandsFrame") or not canExecuteInput("showCommands", "command") then return end
    playSound("open")
    local cf = Instance.new("Frame")
    cf.Name = "CommandsFrame"
    cf.Size = UDim2.new(0, S(isMobile and 320 or 420), 0, S(isMobile and 420 or 520))
    cf.Position = UDim2.new(0.5, -S(isMobile and 160 or 210), 0.5, -S(isMobile and 210 or 260))
    cf.BackgroundColor3 = Theme.background
    cf.BackgroundTransparency = 0.2
    cf.ClipsDescendants = true
    cf.Parent = screenGui
    addCornerAndStroke(cf, S(14), Theme.glassBorder, S(1))
    cf.Size = UDim2.new(0, 0, 0, 0)
    cf.Position = UDim2.new(0.5, 0, 0.5, 0)
    Services.Tween:Create(cf, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(0, S(isMobile and 320 or 420), 0, S(isMobile and 420 or 520)),
        Position = UDim2.new(0.5, -S(isMobile and 160 or 210), 0.5, -S(isMobile and 210 or 260))
    }):Play()
   
    local cfGradient = Instance.new("UIGradient")
    cfGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Theme.background), ColorSequenceKeypoint.new(1, Theme.secondary)}
    cfGradient.Rotation = 90
    cfGradient.Parent = cf
   
    local ch = Instance.new("Frame")
    ch.Size = UDim2.new(1, 0, 0, S(isMobile and 40 or 50))
    ch.BackgroundColor3 = Theme.secondary
    ch.BackgroundTransparency = 0.4
    ch.Parent = cf
    makeDraggable(cf, ch)
    addCornerAndStroke(ch, S(14))
   
    local ct = Instance.new("TextLabel")
    ct.Size = UDim2.new(1, -S(45), 1, 0)
    ct.Position = UDim2.new(0, S(14), 0, 0)
    ct.BackgroundTransparency = 1
    ct.Text = "Command List"
    ct.TextColor3 = Theme.text
    ct.TextSize = S(isMobile and 13 or 17)
    ct.Font = Enum.Font.GothamBold
    ct.TextXAlignment = Enum.TextXAlignment.Left
    ct.Parent = ch
   
    local ctStroke = Instance.new("UIStroke")
    ctStroke.Color = Theme.accent
    ctStroke.Thickness = S(1)
    ctStroke.Transparency = 0.7
    ctStroke.Parent = ct
   
    local cx = Instance.new("TextButton")
    cx.Size = UDim2.new(0, S(isMobile and 25 or 35), 0, S(isMobile and 25 or 35))
    cx.Position = UDim2.new(1, -S(isMobile and 32 or 42), 0.5, -S(isMobile and 12.5 or 17.5))
    cx.BackgroundColor3 = Theme.danger
    cx.BackgroundTransparency = 0.3
    cx.Text = "X"
    cx.TextColor3 = Theme.text
    cx.TextSize = S(isMobile and 13 or 17)
    cx.Font = Enum.Font.SourceSans
    cx.AutoButtonColor = false
    cx.Parent = ch
    addCornerAndStroke(cx, S(8))
   
    cx.MouseEnter:Connect(function()
        if not canExecuteInput("cmdCloseHover", "button") then return end
        playSound("hover")
        Services.Tween:Create(cx, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.1, Rotation = 90}):Play()
    end)
    cx.MouseLeave:Connect(function()
        Services.Tween:Create(cx, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.3, Rotation = 0}):Play()
    end)
    cx.MouseButton1Click:Connect(function()
        if not canExecuteInput("cmdClose", "button") then return end
        playSound("close")
        Services.Tween:Create(cf, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Size = UDim2.new(0, 0, 0, 0),
            Position = UDim2.new(0.5, 0, 0.5, 0)
        }):Play()
        task.wait(0.25)
        cf:Destroy()
    end)
   
    local cs = Instance.new("ScrollingFrame")
    cs.Size = UDim2.new(1, -S(10), 1, -S(isMobile and 45 or 55))
    cs.Position = UDim2.new(0, S(5), 0, S(isMobile and 45 or 55))
    cs.BackgroundColor3 = Theme.secondary
    cs.BackgroundTransparency = 0.8
    cs.BorderSizePixel = 0
    cs.ScrollBarThickness = S(isMobile and 2 or 3)
    cs.ScrollBarImageColor3 = Theme.accent
    cs.ScrollBarImageTransparency = 0.45
    cs.AutomaticCanvasSize = Enum.AutomaticSize.Y
    cs.Parent = cf
    addCornerAndStroke(cs, S(12))
   
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, S(5))
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Parent = cs
   
    for i, c in ipairs(cmds) do
        task.spawn(function()
            task.wait(i * 0.02)
           
            local ci = Instance.new("Frame")
            ci.Size = UDim2.new(1, 0, 0, S(isMobile and 50 or 55))
            ci.BackgroundColor3 = Theme.tertiary
            ci.BackgroundTransparency = 0.5
            ci.LayoutOrder = i
            ci.Parent = cs
            addCornerAndStroke(ci, S(10), Theme.glassBorder, S(1))
           
            ci.BackgroundTransparency = 1
            Services.Tween:Create(ci, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.5}):Play()
           
            ci.MouseEnter:Connect(function()
                Services.Tween:Create(ci, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.3}):Play()
            end)
           
            ci.MouseLeave:Connect(function()
                Services.Tween:Create(ci, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 0.5}):Play()
            end)
           
            local cn = Instance.new("TextLabel")
            cn.Size = UDim2.new(1, -S(18), 0, S(isMobile and 20 or 25))
            cn.Position = UDim2.new(0, S(10), 0, S(4))
            cn.BackgroundTransparency = 1
            cn.Text = Config.commandPrefix .. c[1]
            cn.TextColor3 = Theme.accent
            cn.TextSize = S(isMobile and 11 or 13)
            cn.Font = Enum.Font.GothamBold
            cn.TextXAlignment = Enum.TextXAlignment.Left
            cn.Parent = ci
           
            local cd = Instance.new("TextLabel")
            cd.Size = UDim2.new(1, -S(18), 0, S(isMobile and 16 or 21))
            cd.Position = UDim2.new(0, S(10), 0, S(isMobile and 22 or 28))
            cd.BackgroundTransparency = 1
            cd.Text = c[2]
            cd.TextColor3 = Theme.textSecondary
            cd.TextSize = S(isMobile and 9 or 11)
            cd.Font = Enum.Font.Gotham
            cd.TextXAlignment = Enum.TextXAlignment.Left
            cd.Parent = ci
        end)
    end
end
-- Create UI toggles and buttons
local farmToggles = {}
local farmConnections = {}

local ffFrame, ffToggle = createToggle("Fast Farm", function(enabled, toggleBtn)
    State.fastFarm = enabled
    if enabled and State.slowFarm then
        State.slowFarm = false
        if farmToggles.slow then
            farmToggles.slow.Text = "OFF"
            pcall(function()
                Services.Tween:Create(farmToggles.slow, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
                    BackgroundColor3 = Theme.danger,
                    Rotation = 0
                }):Play()
            end)
        end
    end
    
    -- Disconnect old connection
    if farmConnections.fast then
        farmConnections.fast:Disconnect()
        farmConnections.fast = nil
    end
    
    if enabled then
        Stats.farmStartPower = Stats.power or 0
        Stats.powerGainedFarming = 0
        powerHistory = {{time = time(), power = Stats.power}}
        notification("Fast farm ON - Persists through death", 2, "success")
        
        -- Create persistent connection
        farmConnections.fast = Services.Run.Heartbeat:Connect(function()
            if State.fastFarm and player.Character then
                local effectiveSpeed = Config.speed * FARM_CONFIG.FAST_MULTIPLIER
                farm(math.ceil(effectiveSpeed))
            end
        end)
    else
        notification("Fast farm OFF", 2, "info")
    end
end, {key = "speed", min = 1, max = 10})
farmToggles.fast = ffToggle

local sfFrame, sfToggle = createToggle("Slow Farm", function(enabled, toggleBtn)
    State.slowFarm = enabled
    if enabled and State.fastFarm then
        State.fastFarm = false
        if farmToggles.fast then
            farmToggles.fast.Text = "OFF"
            pcall(function()
                Services.Tween:Create(farmToggles.fast, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
                    BackgroundColor3 = Theme.danger,
                    Rotation = 0
                }):Play()
            end)
        end
        if farmConnections.fast then
            farmConnections.fast:Disconnect()
            farmConnections.fast = nil
        end
    end
    
    -- Disconnect old connection
    if farmConnections.slow then
        farmConnections.slow:Disconnect()
        farmConnections.slow = nil
    end
    
    if enabled then
        Stats.farmStartPower = Stats.power or 0
        Stats.powerGainedFarming = 0
        powerHistory = {{time = time(), power = Stats.power}}
        notification("Slow farm ON - Persists through death", 2, "success")
        
        -- Create persistent connection
        farmConnections.slow = Services.Run.Heartbeat:Connect(function()
            if State.slowFarm and player.Character then
                local effectiveSpeed = Config.speed * FARM_CONFIG.SLOW_MULTIPLIER
                farm(math.ceil(effectiveSpeed))
                task.wait(FARM_CONFIG.DELAY)
            end
        end)
    else
        notification("Slow farm OFF", 2, "info")
    end
end)
farmToggles.slow = sfToggle
local godFrame, godToggleBtn = createToggle("God Mode", function(enabled)
    setLocalGodMode(enabled)
end)
Data.uiElements.godModeToggle = godToggleBtn
createToggle("Kill Aura", function(e)
    State.killAura = e
    if State.coroutines.killAura then
        task.cancel(State.coroutines.killAura)
        State.coroutines.killAura = nil
    end
    notification("Kill aura " .. (e and "ON" or "OFF"), 2, e and "success" or "info")
    if e then
        State.coroutines.killAura = task.spawn(function()
            while State.killAura do
                if player.Character then
                    local rp = player.Character:FindFirstChild("HumanoidRootPart")
                    if rp then
                        for _, p in pairs(Players:GetPlayers()) do
                            if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid and humanoid.Health > 0 then
                                    local distance = (rp.Position - p.Character.HumanoidRootPart.Position).Magnitude
                                    if distance <= Config.killAuraRange then
                                        task.spawn(killPlayerWithVerification, p)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.5)
            end
        end)
    end
end, {key = "killAuraRange", min = 1, max = 100})
createToggle("Reverse Damage", function(e)
    executeCmd(";reversedmg", player)
end)
createButton("Kill All Players", function()
    executeCmd(";kill all", player)
end, Theme.danger)
createButton("God Mode Others", function()
    executeCmd(";god others", player)
end, Theme.accent)
createButton("Heal All Players", function()
    executeCmd(";heal all", player)
end, Theme.heal)
createButton("Reset Session Statistics", function()
    Stats.powerGainedFarming = 0
    Stats.sessionStartTime = time()
    Stats.initialPower = Stats.power
    Stats.kills = 0
    Stats.farmingTime = 0
    powerHistory = {}
    notification("Session stats reset", 3, "success")
end, Theme.info)
createButton("View Commands", showCommandsUI, Theme.accent)
-- Command Bar Functions
local function showCmd()
    if State.commandBarVisible or not canExecuteInput("showCmd", "command") then return end
    State.commandBarVisible = true
    commandBar.Visible = true
    playSound("open")
    Services.Tween:Create(commandBar, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, -S(isMobile and 150 or 200), 1, -S(isMobile and 60 or 75))
    }):Play()
    Services.Tween:Create(accentLine, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 0, S(1))
    }):Play()
    task.spawn(function()
        task.wait(0.15)
        cmdInput:CaptureFocus()
    end)
end
local function hideCmd()
    if not State.commandBarVisible or not canExecuteInput("hideCmd", "button") then return end
    State.commandBarVisible = false
    cmdInput:ReleaseFocus()
    playSound("close")
    Services.Tween:Create(accentLine, TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, S(1))
    }):Play()
    Services.Tween:Create(commandBar, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
        Position = UDim2.new(0.5, -S(isMobile and 150 or 200), 1, S(100))
    }):Play()
    task.spawn(function()
        task.wait(0.25)
        if not State.commandBarVisible then
            commandBar.Visible = false
        end
    end)
end
execBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("execBtn", "command") then return end
    playSound("click")
    executeCmd(Config.commandPrefix .. cmdInput.Text, player)
    cmdInput.Text = ""
    hideCmd()
end)
cmdInput.FocusLost:Connect(function(enter)
    if enter and canExecuteInput("cmdEnter", "command") then
        executeCmd(Config.commandPrefix .. cmdInput.Text, player)
        cmdInput.Text = ""
    end
    hideCmd()
end)
Services.UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.Semicolon and not cmdInput:IsFocused() then
        if canExecuteInput("semicolon", "command") then
            showCmd()
            task.wait()
            cmdInput.Text = ""
        end
    elseif input.KeyCode == Enum.KeyCode.Escape and State.commandBarVisible then
        hideCmd()
    elseif input.KeyCode == Enum.KeyCode.Insert then
        if canExecuteInput("insert", "command") then
            mainFrame.Visible = not mainFrame.Visible
            playSound(mainFrame.Visible and "open" or "close")
        end
    end
end)
minimizeBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("minimizeClick", "button") then return end
    playSound("click")
    State.isMinimized = not State.isMinimized
    local headerHeight = header.AbsoluteSize.Y
    local minimizedSize = UDim2.new(Data.originalUISize.X.Scale, Data.originalUISize.X.Offset, 0, headerHeight)
    if State.isMinimized then
        content.Visible = false
        minimizeBtn.Text = "â˜"
        Services.Tween:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Size = minimizedSize}):Play()
    else
        content.Visible = true
        minimizeBtn.Text = "-"
        Services.Tween:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Size = Data.originalUISize}):Play()
    end
end)
closeBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("closeBtn", "command") then return end
    playSound("close")
    State.flying = false
    executeCmd(";unfly", player)
    for name, c in pairs(Data.connections) do
        if c then
            pcall(c.Disconnect, c)
        end
    end
    stopProtection()
    for _, conn in pairs(Data.speedConnections) do
        if conn then
            pcall(conn.Disconnect, conn)
        end
    end
    for _, conn in pairs(State.loopKillConnections) do
        if conn then
            pcall(conn.Disconnect, conn)
        end
    end
    for _, coroutine in pairs(State.coroutines) do
        if coroutine then
            task.cancel(coroutine)
        end
    end
    Services.Tween:Create(mainFrame, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        Rotation = 180
    }):Play()
    task.wait(0.35)
    if Sounds.hover and Sounds.hover.Parent then
        Sounds.hover.Parent:Destroy()
    end
    screenGui:Destroy()
end)
-- Main Loop
local lastLoop = 0
local updateInterval = 0.05
local mainLoop = Services.Run.Heartbeat:Connect(function(step)
    Performance.fps = math.floor(1/step)
    local t = time()
    if t - lastLoop < updateInterval then return end
    lastLoop = t
    pcall(updatePerformanceMetrics)
    pcall(updateStats, step)
end)
table.insert(Data.connections, mainLoop)
-- Character Management
local function onChar(char)
    if not char then return end
    updateToolCache(player)
    
    char.ChildAdded:Connect(function() updateToolCache(player) end)
    char.ChildRemoved:Connect(function() updateToolCache(player) end)
    
    local backpack = player:WaitForChild("Backpack")
    backpack.ChildAdded:Connect(function() updateToolCache(player) end)
    backpack.ChildRemoved:Connect(function() updateToolCache(player) end)
    
    local h = char:WaitForChild("Humanoid", 5)
    if h then
        h.WalkSpeed = State.speedHack and (Config.flySpeed or 50) or Config.walkSpeed
        h.JumpPower = Config.jumpPower
       
        if State.reverseDmg then
            task.wait(0.5)
            setupReverseDamage()
        end
       
        if State.speedHack then
            toggleSpeedHack(true, Config.flySpeed or 50)
        end
       
        if State.noclip and Data.noclipConnection then
            Data.noclipConnection:Disconnect()
            Data.noclipConnection = Services.Run.Stepped:Connect(function()
                if player.Character then
                    for _, p in pairs(player.Character:GetDescendants()) do
                        if p:IsA("BasePart") and p.CanCollide then
                            p.CanCollide = false
                        end
                    end
                end
            end)
        end
       
        if State.godMode then
            task.spawn(function()
                task.wait(0.5)
                setLocalGodMode(true)
            end)
        end
        
        -- Farming connections persist automatically - no restart needed
    end
end

if player.Character then onChar(player.Character) end
player.CharacterAdded:Connect(onChar)
table.insert(Data.adminPlayers, player.Name)
Stats.sessionStartTime = time()
commandBar.Visible = false
-- Whitelist Check
local function checkAdminOnJoin(p)
    for _, id in ipairs(Config.whitelistedIds) do
        if p.UserId == id then
            if not table.find(Data.adminPlayers, p.Name) then
                table.insert(Data.adminPlayers, p.Name)
            end
            break
        end
    end
end
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= player then
        checkAdminOnJoin(p)
    end
end
Players.PlayerAdded:Connect(checkAdminOnJoin)
-- Chat Command Processing
local function processMessage(msg)
    if msg.Text:sub(1, 1) == Config.commandPrefix then
        local source = Players:GetPlayerByUserId(msg.TextSource.UserId)
        if source and (source == player or table.find(Data.adminPlayers, source.Name)) then
            task.spawn(executeCmd, msg.Text, source)
            return true
        end
    end
    return false
end
if Services.TextChat and Services.TextChat.ChatVersion == Enum.ChatVersion.TextChatService then
    pcall(function()
        Services.TextChat.OnIncomingMessage = function(message)
            if message.Status ~= Enum.TextChatMessageStatus.Success then return end
            processMessage(message)
        end
    end)
else
    player.Chatted:Connect(function(msg)
        task.spawn(executeCmd, msg, player)
    end)
end
-- Startup Animation
task.spawn(function()
    mainFrame.Size = UDim2.new(0, 0, 0, 0)
    mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    performanceFrame.Position = UDim2.new(1, S(40), 0, S(10))
    Services.Tween:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(0, S(isMobile and 350 or 450), 0, S(isMobile and 550 or 650)),
        Position = UDim2.new(0.5, -S(isMobile and 175 or 225), 0.5, -S(isMobile and 275 or 325)),
        Rotation = 0
    }):Play()
    Services.Tween:Create(performanceFrame, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(1, -S(190), 0, S(10))
    }):Play()
    notification("2TAKE1 ULTRA - Pro Version (2026) Loaded!", 3, "success")
    task.wait(2)
    notification("Press ; for commands or INSERT to toggle UI", 3, "info")
end)

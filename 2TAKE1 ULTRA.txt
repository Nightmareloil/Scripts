-- 2take1 Hub Script 2025 Ultra Edition
--[!] PATCH NOTES:
--    - ';dmg' command now supports 'all' and 'others' targets.
--    - ';admin' and ';unadmin' commands now support 'all' and 'others' targets.
--    - Command execution order (others first, then self) is now respected for the ';dmg' command.
--    - Hardened admin command logic remains consistent across all commands.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Services = {
    TextChat = game:GetService("TextChatService"),
    UIS = game:GetService("UserInputService"),
    Tween = game:GetService("TweenService"),
    Run = game:GetService("RunService"),
    Teleport = game:GetService("TeleportService"),
    Http = game:GetService("HttpService"),
    StarterGui = game:GetService("StarterGui"),
    Stats = game:GetService("Stats"),
    Debris = game:GetService("Debris"),
    Lighting = game:GetService("Lighting"),
    SoundService = game:GetService("SoundService")
}

if not game:IsLoaded() then game.Loaded:Wait() end

-- Performance Tracking
local Performance = {
    fps = 0,
    ping = 0
}

-- Optimized Sound System
local Sounds = {}
local soundIds = {
    hover = "rbxassetid://10066936758",
    click = "rbxassetid://876939830",
    open = "rbxassetid://5274478178",
    close = "rbxassetid://5274478067",
    success = "rbxassetid://6895079853",
    error = "rbxassetid://5332680810",
    typing = "rbxassetid://9113651327",
    combat = "rbxassetid://9116885820",
    shield = "rbxassetid://9125527144"
}

local function createSounds()
    local soundFolder = Instance.new("Folder")
    soundFolder.Name = "2take1Sounds"
    soundFolder.Parent = Services.SoundService

    for name, id in pairs(soundIds) do
        local sound = Instance.new("Sound")
        sound.SoundId = id
        sound.Volume = name == "typing" and 0.15 or name == "hover" and 0.2 or 0.4
        sound.Parent = soundFolder
        Sounds[name] = sound
    end
end
createSounds()

-- Enhanced Input Debouncing System
local InputManager = {
    cooldowns = {},
    globalCooldown = 0,
    minInputDelay = 0.1,
    buttonCooldown = 0.2,
    commandCooldown = 0.05
}

local function playSound(soundName)
    local currentTime = tick()
    if currentTime - InputManager.globalCooldown < 0.03 then return end

    local sound = Sounds[soundName]
    if sound then
        task.spawn(function()
            sound:Play()
        end)
        InputManager.globalCooldown = currentTime
    end
end

local function canExecuteInput(inputId, cooldownType)
    local currentTime = tick()
    local cooldownTime = InputManager.minInputDelay

    if cooldownType == "button" then
        cooldownTime = InputManager.buttonCooldown
    elseif cooldownType == "command" then
        cooldownTime = InputManager.commandCooldown
    end

    local lastTime = InputManager.cooldowns[inputId] or 0
    if currentTime - lastTime >= cooldownTime then
        InputManager.cooldowns[inputId] = currentTime
        return true
    end
    return false
end

-- Optimized UI Scaling System
local UIScale = {
    userScale = 1.0,
    minScale = 0.6,
    maxScale = 1.4,
    baseReferenceSize = 1080,
    cached = {scale = nil, mobile = nil}
}

local function getOptimizedScaleFactor()
    if UIScale.cached.scale then
        return UIScale.cached.scale, UIScale.cached.mobile
    end

    local viewport = workspace.CurrentCamera.ViewportSize
    local isMobile = Services.UIS.TouchEnabled and not Services.UIS.KeyboardEnabled

    local screenHeight = viewport.Y
    local screenWidth = viewport.X
    local aspectRatio = screenWidth / screenHeight

    local baseScale = screenHeight / UIScale.baseReferenceSize
    local aspectMultiplier = aspectRatio > 1.8 and 0.95 or aspectRatio < 1.2 and 1.05 or 1.0
    local platformScale = isMobile and 0.9 or 1.0
    local autoScale = baseScale * aspectMultiplier * platformScale

    autoScale = math.clamp(autoScale, isMobile and 0.7 or 0.8, isMobile and 1.3 or 1.5)
    local finalScale = math.clamp(autoScale * UIScale.userScale, UIScale.minScale, UIScale.maxScale)

    UIScale.cached.scale = finalScale
    UIScale.cached.mobile = isMobile

    return finalScale, isMobile
end

local scaleFactor, isMobile = getOptimizedScaleFactor()

local function S(offset)
    return math.max(1, math.floor(offset * scaleFactor + 0.5))
end

local function updateUIScale()
    UIScale.cached = {scale = nil, mobile = nil}
    scaleFactor, isMobile = getOptimizedScaleFactor()
end

-- Configuration
local Config = {
    speed = 8, range = S(15), walkSpeed = 16, jumpPower = 50, flySpeed = S(40),
    commandPrefix = ";", antiLagEnabled = false, performanceMode = false,
    whitelistedIds = {1234567, 7654321}
}

-- Optimized State Management
local State = {
    fastFarm = false, slowFarm = false, godMode = false, killAura = false,
    flying = false, noclip = false, commandBarVisible = false, loopKillActive = false,
    loopKillConnections = {},
    watchingPlayer = nil, reverseDmg = false, speedHack = false,
    protectedPlayer = nil, protectionActive = false,
    coroutines = {}
}

-- Enhanced Statistics
local Stats = {
    power = 0, kills = 0, health = 100, powerGainedThisSession = 0,
    sessionStartTime = tick(), powerPerSecond = 0, powerPerHour = 0,
    basePower = 0, accuracy = 100, damageDealt = 0, damageReceived = 0,
    healsGiven = 0, deaths = 0, killStreak = 0, bestKillStreak = 0,
    farmingTime = 0, totalCommands = 0
}

-- Data Storage
local Data = {
    adminPlayers = {}, connections = {}, flyObjects = {},
    noclipConnection = nil, flyConnection = nil, charDiedFlyConnection = nil,
    watchConnection = nil, reverseDmgConnection = nil, speedConnections = {},
    uiElements = {}, protectionConnection = nil, protectedPlayerConnection = nil,
    toolCache = {}
}

-- Modern Theme
local Theme = {
    background = Color3.fromRGB(18, 18, 28),
    backgroundGlass = Color3.fromRGB(25, 25, 38),
    secondary = Color3.fromRGB(35, 35, 50),
    tertiary = Color3.fromRGB(45, 45, 65),
    accent = Color3.fromRGB(80, 150, 220),
    accentSecondary = Color3.fromRGB(120, 180, 240),
    accentGradient1 = Color3.fromRGB(80, 150, 220),
    accentGradient2 = Color3.fromRGB(120, 180, 240),
    subtleGlow = Color3.fromRGB(100, 160, 230),
    success = Color3.fromRGB(100, 210, 130),
    danger = Color3.fromRGB(230, 90, 90),
    warning = Color3.fromRGB(230, 190, 70),
    info = Color3.fromRGB(110, 160, 210),
    text = Color3.fromRGB(240, 240, 245),
    textSecondary = Color3.fromRGB(180, 180, 200),
    textMuted = Color3.fromRGB(140, 140, 160),
    glow = Color3.fromRGB(120, 170, 230),
    glowSecondary = Color3.fromRGB(140, 190, 240),
    glassBorder = Color3.fromRGB(200, 200, 220),
    glassReflection = Color3.fromRGB(255, 255, 255),
    protection = Color3.fromRGB(200, 170, 80),
    heal = Color3.fromRGB(130, 210, 110),
    damage = Color3.fromRGB(210, 110, 150)
}

-- Utility Functions
local function protectGui(gui)
    if syn and syn.protect_gui then syn.protect_gui(gui)
    elseif gethui then gui.Parent = gethui() return end
    pcall(function() gui.Parent = game:GetService("CoreGui") end)
end

local function notification(text, duration, type)
    if not canExecuteInput("notification", "button") then return end

    duration = duration or 3
    local iconMap = {
        success = "rbxassetid://7743878358",
        error = "rbxassetid://7743877738",
        warning = "rbxassetid://7743878496",
        combat = "rbxassetid://7743878358"
    }

    local icon = iconMap[type] or "rbxassetid://7733964640"

    if type and type ~= "info" then
        playSound(type == "combat" and "combat" or type)
    end

    pcall(function()
        Services.StarterGui:SetCore("SendNotification", {
            Title = "2TAKE1 ULTRA 2025",
            Text = text,
            Duration = duration,
            Icon = icon
        })
    end)
end

local formatRanges = {
    {1e12, "T"}, {1e9, "B"}, {1e6, "M"}, {1e3, "K"}
}

local function formatNumber(n)
    if not n or n == math.huge or n == -math.huge then return "Inf" end
    for _, range in ipairs(formatRanges) do
        if n >= range[1] then
            return string.format("%.2f%s", n/range[1], range[2])
        end
    end
    return tostring(math.floor(n))
end


local function formatTime(s)
    return string.format("%02d:%02d:%02d", math.floor(s/3600), math.floor((s%3600)/60), math.floor(s%60))
end

local function makeDraggable(frame, handle)
    handle = handle or frame
    local dragging = false
    local dragStart, startPos, inputType = nil, nil, nil
    local lastDragTime = 0
    local dragThrottle = 1/60

    local function beginDrag(input)
        if not canExecuteInput("drag", "button") then return end

        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            inputType = input.UserInputType
            dragStart = input.UserInputType == Enum.UserInputType.Touch and input.Position or Services.UIS:GetMouseLocation()
            startPos = frame.Position
            playSound("click")
        end
    end

    local function endDrag(input)
        if input.UserInputType == inputType then
            dragging = false
            inputType = nil
        end
    end

    local function updateDrag(input)
        local currentTime = tick()
        if dragging and (currentTime - lastDragTime > dragThrottle) then
            lastDragTime = currentTime
            if input.UserInputType == Enum.UserInputType.MouseMovement or
               (dragging and input.UserInputType == Enum.UserInputType.Touch) then
                local currentPos = input.UserInputType == Enum.UserInputType.Touch and input.Position or Services.UIS:GetMouseLocation()
                local delta = currentPos - dragStart
                frame.Position = UDim2.new(
                    startPos.X.Scale, startPos.X.Offset + delta.X,
                    startPos.Y.Scale, startPos.Y.Offset + delta.Y
                )
            end
        end
    end

    handle.InputBegan:Connect(beginDrag)
    handle.InputEnded:Connect(endDrag)
    Services.UIS.InputChanged:Connect(updateDrag)
end

local function addCornerAndStroke(obj, radius, color, strokeWidth)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or S(8))
    corner.Parent = obj

    if color then
        local stroke = Instance.new("UIStroke")
        stroke.Thickness = strokeWidth or S(1)
        stroke.Color = color
        stroke.Transparency = 0.5
        stroke.Parent = obj
    end
end

local function rescaleUI()
    if not screenGui or not screenGui.Parent then return end

    updateUIScale()

    if not Data.uiElements then return end

    local batchSize = 5
    for i = 1, #Data.uiElements, batchSize do
        task.spawn(function()
            local endIdx = math.min(i + batchSize - 1, #Data.uiElements)
            for j = i, endIdx do
                local element = Data.uiElements[j]
                if element and element.obj and element.obj.Parent then
                    pcall(function()
                        if element.size then
                            local newWidth = math.clamp(S(element.size.X.Offset), 50, 800)
                            local newHeight = math.clamp(S(element.size.Y.Offset), 30, 1000)
                            element.obj.Size = UDim2.new(element.size.X.Scale, newWidth, element.size.Y.Scale, newHeight)
                        end
                        if element.position then
                            element.obj.Position = UDim2.new(element.position.X.Scale, S(element.position.X.Offset),
                                                           element.position.Y.Scale, S(element.position.Y.Offset))
                        end
                        if element.textSize then
                            element.obj.TextSize = math.clamp(S(element.textSize), 8, 40)
                        end
                        local corner = element.obj:FindFirstChildOfClass("UICorner")
                        if corner and element.cornerRadius then
                            corner.CornerRadius = UDim.new(0, math.clamp(S(element.cornerRadius), 4, 20))
                        end
                        local stroke = element.obj:FindFirstChildOfClass("UIStroke")
                        if stroke then
                            stroke.Thickness = math.clamp(S(1), 1, 3)
                        end
                    end)
                else
                    table.remove(Data.uiElements, j)
                end
            end
        end)
    end

    Config.range = S(15)
    Config.flySpeed = S(40)
end

local function createScalableElement(obj, sizeOffsets, positionOffsets, textSize, cornerRadius)
    local elementData = {
        obj = obj,
        size = sizeOffsets and UDim2.new(sizeOffsets.X.Scale, sizeOffsets.X.Offset, sizeOffsets.Y.Scale, sizeOffsets.Y.Offset),
        position = positionOffsets and UDim2.new(positionOffsets.X.Scale, positionOffsets.X.Offset, positionOffsets.Y.Scale, positionOffsets.Y.Offset),
        textSize = textSize,
        cornerRadius = cornerRadius
    }
    table.insert(Data.uiElements, elementData)
    return elementData
end

-- Create main GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "2take1HubUltra"
screenGui.ResetOnSpawn = false
protectGui(screenGui)

-- Enhanced Performance Display
local performanceFrame = Instance.new("Frame")
performanceFrame.Size = UDim2.new(0, S(200), 0, S(80))
performanceFrame.Position = UDim2.new(1, -S(210), 0, S(10))
performanceFrame.BackgroundColor3 = Theme.backgroundGlass
performanceFrame.BorderSizePixel = 0
performanceFrame.BackgroundTransparency = 0.2
performanceFrame.Parent = screenGui
addCornerAndStroke(performanceFrame, S(8), Theme.glassBorder, S(1))

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
fpsLabel.Position = UDim2.new(0, S(5), 0, 0)
fpsLabel.BackgroundTransparency = 1
fpsLabel.Text = "FPS: 0"
fpsLabel.TextColor3 = Theme.success
fpsLabel.TextSize = S(12)
fpsLabel.Font = Enum.Font.GothamBold
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Parent = performanceFrame

local pingLabel = Instance.new("TextLabel")
pingLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
pingLabel.Position = UDim2.new(0.5, 0, 0, 0)
pingLabel.BackgroundTransparency = 1
pingLabel.Text = "Ping: 0ms"
pingLabel.TextColor3 = Theme.info
pingLabel.TextSize = S(12)
pingLabel.Font = Enum.Font.GothamBold
pingLabel.TextXAlignment = Enum.TextXAlignment.Left
pingLabel.Parent = performanceFrame

local perfStatsLabel = Instance.new("TextLabel")
perfStatsLabel.Size = UDim2.new(1, -S(10), 0.5, 0)
perfStatsLabel.Position = UDim2.new(0, S(5), 0.5, 0)
perfStatsLabel.BackgroundTransparency = 1
perfStatsLabel.Text = "Memory: 0MB | CPU: 0%"
perfStatsLabel.TextColor3 = Theme.textSecondary
perfStatsLabel.TextSize = S(10)
perfStatsLabel.Font = Enum.Font.Gotham
perfStatsLabel.TextXAlignment = Enum.TextXAlignment.Left
perfStatsLabel.Parent = performanceFrame

local function updatePerformanceMetrics()
    Performance.fps = math.floor(workspace:GetRealPhysicsFPS())
    local fpsColor = Performance.fps >= 55 and Theme.success or Performance.fps >= 28 and Theme.warning or Theme.danger
    fpsLabel.Text = string.format("FPS: %d", Performance.fps)
    fpsLabel.TextColor3 = fpsColor

    local pingStat = Services.Stats.Network:FindFirstChild("ServerStatsItem") and Services.Stats.Network.ServerStatsItem:FindFirstChild("Data Ping")
    if pingStat then
        Performance.ping = math.floor(pingStat:GetValue() or 0)
        local pingColor = Performance.ping <= 80 and Theme.success or Performance.ping <= 150 and Theme.warning or Theme.danger
        pingLabel.Text = "Ping: " .. Performance.ping .. "ms"
        pingLabel.TextColor3 = pingColor
    else
        pingLabel.Text = "Ping: N/A"
        pingLabel.TextColor3 = Theme.textMuted
    end

    local memStats = Services.Stats:FindFirstChild("PerformanceStats")
    if memStats then
        local memoryMB = 0
        pcall(function()
            memoryMB = math.floor((memStats:FindFirstChild("Lua Memory") and memStats["Lua Memory"]:GetValue() or 0) / 1048576)
        end)
        perfStatsLabel.Text = string.format("Memory: %dMB", memoryMB)
    end
end

-- Command bar
local commandBar = Instance.new("Frame")
commandBar.Size = UDim2.new(0, S(isMobile and 360 or 500), 0, S(isMobile and 50 or 65))
commandBar.Position = UDim2.new(0.5, -S(isMobile and 180 or 250), 1, S(100))
commandBar.BackgroundColor3 = Theme.backgroundGlass
commandBar.BorderSizePixel = 0
commandBar.BackgroundTransparency = 0.15
commandBar.ClipsDescendants = true
commandBar.Parent = screenGui
makeDraggable(commandBar)
createScalableElement(commandBar,
    UDim2.new(0, isMobile and 360 or 500, 0, isMobile and 50 or 65),
    UDim2.new(0.5, -(isMobile and 180 or 250), 1, 100), nil, 16)
addCornerAndStroke(commandBar, S(16), Theme.glassBorder, S(1))

local bgGradient1 = Instance.new("UIGradient")
bgGradient1.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.backgroundGlass),
    ColorSequenceKeypoint.new(1, Theme.secondary)
}
bgGradient1.Rotation = 90
bgGradient1.Parent = commandBar

local glassOverlay = Instance.new("Frame")
glassOverlay.Size = UDim2.new(1, 0, 0.4, 0)
glassOverlay.Position = UDim2.new(0, 0, 0, 0)
glassOverlay.BackgroundColor3 = Theme.glassReflection
glassOverlay.BackgroundTransparency = 0.95
glassOverlay.BorderSizePixel = 0
glassOverlay.Parent = commandBar

local overlayGradient = Instance.new("UIGradient")
overlayGradient.Transparency = NumberSequence.new{
    NumberSequenceKeypoint.new(0, 0.85),
    NumberSequenceKeypoint.new(1, 1)
}
overlayGradient.Rotation = 90
overlayGradient.Parent = glassOverlay

local accentLine = Instance.new("Frame")
accentLine.Size = UDim2.new(1, 0, 0, S(1))
accentLine.Position = UDim2.new(0, 0, 1, -S(1))
accentLine.BackgroundColor3 = Theme.accent
accentLine.BorderSizePixel = 0
accentLine.BackgroundTransparency = 0.4
accentLine.Parent = commandBar

local accentGradient = Instance.new("UIGradient")
accentGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.accentGradient1),
    ColorSequenceKeypoint.new(1, Theme.accentGradient2)
}
accentGradient.Parent = accentLine

local cmdIcon = Instance.new("Frame")
cmdIcon.Size = UDim2.new(0, S(40), 0, S(40))
cmdIcon.Position = UDim2.new(0, S(12), 0.5, -S(20))
cmdIcon.BackgroundColor3 = Theme.accent
cmdIcon.BackgroundTransparency = 0.85
cmdIcon.Parent = commandBar
addCornerAndStroke(cmdIcon, S(10), Theme.accent, S(1))

local iconGradient = Instance.new("UIGradient")
iconGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.accentGradient1),
    ColorSequenceKeypoint.new(1, Theme.accentGradient2)
}
iconGradient.Rotation = 135
iconGradient.Parent = cmdIcon

local iconLabel = Instance.new("TextLabel")
iconLabel.Size = UDim2.new(1, 0, 1, 0)
iconLabel.BackgroundTransparency = 1
iconLabel.Text = ""
iconLabel.TextColor3 = Theme.text
iconLabel.TextSize = S(isMobile and 20 or 26)
iconLabel.Font = Enum.Font.SourceSansBold
iconLabel.Parent = cmdIcon
createScalableElement(iconLabel, UDim2.new(1, 0, 1, 0), nil, isMobile and 20 or 26)

local inputContainer = Instance.new("Frame")
inputContainer.Size = UDim2.new(1, -S(isMobile and 160 or 200), 0, S(40))
inputContainer.Position = UDim2.new(0, S(isMobile and 60 or 70), 0.5, -S(20))
inputContainer.BackgroundColor3 = Theme.secondary
inputContainer.BackgroundTransparency = 0.6
inputContainer.Parent = commandBar
addCornerAndStroke(inputContainer, S(10), Theme.glassBorder, S(1))
createScalableElement(inputContainer,
    UDim2.new(1, -(isMobile and 160 or 200), 0, 40),
    UDim2.new(0, isMobile and 60 or 70, 0.5, -20), nil, 10)

local cmdInput = Instance.new("TextBox")
cmdInput.Size = UDim2.new(1, -S(16), 1, -S(6))
cmdInput.Position = UDim2.new(0, S(8), 0, S(3))
cmdInput.BackgroundTransparency = 1
cmdInput.Text = ""
cmdInput.PlaceholderText = "Type command here..."
cmdInput.PlaceholderColor3 = Theme.textMuted
cmdInput.TextColor3 = Theme.text
cmdInput.TextSize = S(isMobile and 13 or 15)
cmdInput.Font = Enum.Font.Gotham
cmdInput.TextXAlignment = Enum.TextXAlignment.Left
cmdInput.Parent = inputContainer
createScalableElement(cmdInput,
    UDim2.new(1, -16, 1, -6),
    UDim2.new(0, 8, 0, 3),
    isMobile and 13 or 15)

local typingIndicator = Instance.new("Frame")
typingIndicator.Size = UDim2.new(0, S(2), 0, S(18))
typingIndicator.Position = UDim2.new(0, S(8), 0.5, -S(9))
typingIndicator.BackgroundColor3 = Theme.accent
typingIndicator.BorderSizePixel = 0
typingIndicator.Visible = false
typingIndicator.Parent = inputContainer

local execBtn = Instance.new("TextButton")
execBtn.Size = UDim2.new(0, S(isMobile and 80 or 110), 0, S(40))
execBtn.Position = UDim2.new(1, -S(isMobile and 90 or 120), 0.5, -S(20))
execBtn.BackgroundColor3 = Theme.accent
execBtn.Text = ""
execBtn.AutoButtonColor = false
execBtn.Parent = commandBar
addCornerAndStroke(execBtn, S(10), Theme.accent, S(1))
createScalableElement(execBtn,
    UDim2.new(0, isMobile and 80 or 110, 0, 40),
    UDim2.new(1, -(isMobile and 90 or 120), 0.5, -20),
    nil, 10)

local btnGradient = Instance.new("UIGradient")
btnGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.accentGradient1),
    ColorSequenceKeypoint.new(1, Theme.accentGradient2)
}
btnGradient.Rotation = 135
btnGradient.Parent = execBtn

local btnText = Instance.new("TextLabel")
btnText.Size = UDim2.new(1, 0, 1, 0)
btnText.BackgroundTransparency = 1
btnText.Text = "RUN"
btnText.TextColor3 = Theme.text
btnText.TextSize = S(isMobile and 11 or 13)
btnText.Font = Enum.Font.GothamBold
btnText.Parent = execBtn
createScalableElement(btnText, UDim2.new(1, 0, 1, 0), nil, isMobile and 11 or 13)

local btnHovering = false
execBtn.MouseEnter:Connect(function()
    if not canExecuteInput("btnHover", "button") then return end
    btnHovering = true
    playSound("hover")
    Services.Tween:Create(execBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
        Size = UDim2.new(0, S(isMobile and 85 or 115), 0, S(42))
    }):Play()
end)

execBtn.MouseLeave:Connect(function()
    btnHovering = false
    Services.Tween:Create(execBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
        Size = UDim2.new(0, S(isMobile and 80 or 110), 0, S(40))
    }):Play()
end)

execBtn.MouseButton1Down:Connect(function()
    if not canExecuteInput("btnPress", "button") then return end
    Services.Tween:Create(execBtn, TweenInfo.new(0.1), {
        Size = UDim2.new(0, S(isMobile and 78 or 108), 0, S(38))
    }):Play()
end)

execBtn.MouseButton1Up:Connect(function()
    local targetSize = btnHovering and
        UDim2.new(0, S(isMobile and 85 or 115), 0, S(42)) or
        UDim2.new(0, S(isMobile and 80 or 110), 0, S(40))
    Services.Tween:Create(execBtn, TweenInfo.new(0.1), {Size = targetSize}):Play()
end)

cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
    if cmdInput.Text ~= "" then
        typingIndicator.Visible = true
        Services.Tween:Create(typingIndicator, TweenInfo.new(0.7, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true), {
            BackgroundTransparency = 0.6
        }):Play()

        if math.random() > 0.7 and canExecuteInput("typing", "button") then
            playSound("typing")
        end
    else
        typingIndicator.Visible = false
    end
end)

-- Main frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, S(isMobile and 380 or 480), 0, S(isMobile and 720 or 820))
mainFrame.Position = UDim2.new(0.5, -S(isMobile and 190 or 240), 0.5, -S(isMobile and 360 or 410))
mainFrame.BackgroundColor3 = Theme.background
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = 0
mainFrame.ClipsDescendants = true
mainFrame.Parent = screenGui
addCornerAndStroke(mainFrame, S(14), Theme.glassBorder, S(1))
createScalableElement(mainFrame,
    UDim2.new(0, isMobile and 380 or 480, 0, isMobile and 720 or 820),
    UDim2.new(0.5, -(isMobile and 190 or 240), 0.5, -(isMobile and 360 or 410)), nil, 14)

local mainGradient = Instance.new("UIGradient")
mainGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.background),
    ColorSequenceKeypoint.new(0.5, Theme.secondary),
    ColorSequenceKeypoint.new(1, Theme.background)
}
mainGradient.Rotation = 90
mainGradient.Parent = mainFrame

local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, S(isMobile and 45 or 55))
header.BackgroundColor3 = Theme.secondary
header.BackgroundTransparency = 0.4
header.Parent = mainFrame
makeDraggable(mainFrame, header)
addCornerAndStroke(header, S(14))
createScalableElement(header,
    UDim2.new(1, 0, 0, isMobile and 45 or 55), nil, nil, 14)

local headerGradient = Instance.new("UIGradient")
headerGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.secondary),
    ColorSequenceKeypoint.new(1, Theme.tertiary)
}
headerGradient.Rotation = 90
headerGradient.Parent = header

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -S(90), 1, 0)
title.Position = UDim2.new(0, S(16), 0, 0)
title.BackgroundTransparency = 1
title.Text = "2TAKE1 ULTRA"
title.TextColor3 = Theme.text
title.TextSize = S(isMobile and 16 or 20)
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header
createScalableElement(title,
    UDim2.new(1, -90, 1, 0), UDim2.new(0, 16, 0, 0),
    isMobile and 16 or 20)

local titleStroke = Instance.new("UIStroke")
titleStroke.Color = Theme.accent
titleStroke.Thickness = S(1)
titleStroke.Transparency = 0.75
titleStroke.Parent = title

task.spawn(function()
    while header.Parent do
        Services.Tween:Create(titleStroke, TweenInfo.new(3.5, Enum.EasingStyle.Sine), {
            Transparency = 0.6
        }):Play()
        task.wait(3.5)
        Services.Tween:Create(titleStroke, TweenInfo.new(3.5, Enum.EasingStyle.Sine), {
            Transparency = 0.8
        }):Play()
        task.wait(3.5)
    end
end)

local scaleContainer = Instance.new("Frame")
scaleContainer.Name = "ScaleContainer"
scaleContainer.Size = UDim2.new(0, S(70), 0, S(25))
scaleContainer.Position = UDim2.new(1, -S(110), 0.5, -S(12.5))
scaleContainer.BackgroundColor3 = Theme.tertiary
scaleContainer.BackgroundTransparency = 0.6
scaleContainer.Parent = header
addCornerAndStroke(scaleContainer, S(6), Theme.glassBorder, S(1))

local scaleInput = Instance.new("TextBox")
scaleInput.Name = "ScaleInput"
scaleInput.Size = UDim2.new(1, -S(6), 1, 0)
scaleInput.Position = UDim2.new(0, S(3), 0, 0)
scaleInput.BackgroundTransparency = 1
scaleInput.Text = tostring(math.floor(UIScale.userScale * 100 + 0.5)) .. "%"
scaleInput.TextColor3 = Theme.text
scaleInput.TextSize = S(isMobile and 9 or 11)
scaleInput.Font = Enum.Font.Gotham
scaleInput.Parent = scaleContainer
createScalableElement(scaleInput,
    UDim2.new(1, -6, 1, 0),
    UDim2.new(0, 3, 0, 0),
    isMobile and 9 or 11)

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, S(30), 0, S(30))
closeBtn.Position = UDim2.new(1, -S(36), 0.5, -S(15))
closeBtn.BackgroundColor3 = Theme.danger
closeBtn.BackgroundTransparency = 0.3
closeBtn.Text = "X"
closeBtn.TextColor3 = Theme.text
closeBtn.TextSize = S(isMobile and 16 or 20)
closeBtn.Font = Enum.Font.SourceSans
closeBtn.AutoButtonColor = false
closeBtn.Parent = header
addCornerAndStroke(closeBtn, S(8))
createScalableElement(closeBtn,
    UDim2.new(0, 30, 0, 30),
    UDim2.new(1, -36, 0.5, -15),
    isMobile and 16 or 20, 8)

closeBtn.MouseEnter:Connect(function()
    if not canExecuteInput("closeHover", "button") then return end
    playSound("hover")
    Services.Tween:Create(closeBtn, TweenInfo.new(0.2), {
        BackgroundTransparency = 0.1,
        Rotation = 90
    }):Play()
end)

closeBtn.MouseLeave:Connect(function()
    Services.Tween:Create(closeBtn, TweenInfo.new(0.2), {
        BackgroundTransparency = 0.3,
        Rotation = 0
    }):Play()
end)

local content = Instance.new("ScrollingFrame")
content.Name = "Content"
content.Size = UDim2.new(1, -S(12), 1, -S(isMobile and 50 or 60))
content.Position = UDim2.new(0, S(6), 0, S(isMobile and 50 or 60))
content.BackgroundColor3 = Theme.secondary
content.BackgroundTransparency = 0.8
content.BorderSizePixel = 0
content.ScrollBarThickness = S(isMobile and 2 or 3)
content.ScrollBarImageColor3 = Theme.accent
content.ScrollBarImageTransparency = 0.5
content.AutomaticCanvasSize = Enum.AutomaticSize.Y
content.Parent = mainFrame
addCornerAndStroke(content, S(10))
createScalableElement(content,
    UDim2.new(1, -12, 1, -(isMobile and 50 or 60)),
    UDim2.new(0, 6, 0, isMobile and 50 or 60), nil, 10)

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, S(8))
layout.Parent = content

local statsFrame = Instance.new("Frame")
statsFrame.Name = "StatsFrame"
statsFrame.Size = UDim2.new(1, -S(6), 0, S(isMobile and 580 or 680))
statsFrame.BackgroundColor3 = Theme.tertiary
statsFrame.BackgroundTransparency = 0.4
statsFrame.BorderSizePixel = 0
statsFrame.Parent = content
addCornerAndStroke(statsFrame, S(10), Theme.glassBorder, S(1))
createScalableElement(statsFrame,
    UDim2.new(1, -6, 0, isMobile and 580 or 680), nil, nil, 10)

local statsGradient = Instance.new("UIGradient")
statsGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Theme.tertiary),
    ColorSequenceKeypoint.new(1, Theme.secondary)
}
statsGradient.Rotation = 90
statsGradient.Parent = statsFrame

local statLabels = {}

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -S(30), 0, S(30))
titleLabel.Position = UDim2.new(0, S(15), 0, S(12))
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Player Statistics & Analytics"
titleLabel.TextColor3 = Theme.accent
titleLabel.TextSize = S(isMobile and 16 or 20)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextYAlignment = Enum.TextYAlignment.Center
titleLabel.Parent = statsFrame
statLabels["title"] = titleLabel

local statPositions = {
    {name = "power", text = "Power: 0", x = 0, y = 50, width = 0.35, align = Enum.TextXAlignment.Left},
    {name = "kills", text = "Kills: 0", x = 0.35, y = 50, width = 0.30, align = Enum.TextXAlignment.Left},
    {name = "health", text = "Health: 100", x = 0.65, y = 50, width = 0.35, align = Enum.TextXAlignment.Right},
    {name = "fps", text = "FPS: 0", x = 0, y = 80, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "ping", text = "Ping: 0ms", x = 0.25, y = 80, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "accuracy", text = "Accuracy: 100%", x = 0.5, y = 80, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "tools", text = "Tools: 0", x = 0.75, y = 80, width = 0.25, align = Enum.TextXAlignment.Left},
    {name = "pph", text = "Power/hr: 0", x = 0, y = 110, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "session", text = "Session: +0", x = 0.5, y = 110, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "killStreak", text = "Kill Streak: 0", x = 0, y = 140, width = 0.33, align = Enum.TextXAlignment.Left},
    {name = "bestStreak", text = "Best: 0", x = 0.33, y = 140, width = 0.33, align = Enum.TextXAlignment.Left},
    {name = "deaths", text = "Deaths: 0", x = 0.66, y = 140, width = 0.34, align = Enum.TextXAlignment.Left},
    {name = "damageDealt", text = "Damage Dealt: 0", x = 0, y = 170, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "damageReceived", text = "Damage Taken: 0", x = 0.5, y = 170, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "healsGiven", text = "Heals Given: 0", x = 0, y = 200, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "farmingTime", text = "Farm Time: 00:00:00", x = 0.5, y = 200, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "time", text = "Session: 00:00:00", x = 0, y = 230, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "commands", text = "Commands: 0", x = 0.5, y = 230, width = 0.5, align = Enum.TextXAlignment.Left},
    {name = "eff", text = "Efficiency: Calculating...", x = 0, y = 260, width = 1, align = Enum.TextXAlignment.Left},
}

for _, stat in ipairs(statPositions) do
    local label = Instance.new("TextLabel")
    local xOffset = stat.align == Enum.TextXAlignment.Right and -S(15) or S(15)
    label.Size = UDim2.new(stat.width, -S(10), 0, S(25))
    label.Position = UDim2.new(stat.x, xOffset, 0, S(stat.y))
    label.BackgroundTransparency = 1
    label.Text = stat.text
    label.TextColor3 = Theme.text
    label.TextSize = S(isMobile and 11 or 13)
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = stat.align
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = statsFrame
    statLabels[stat.name] = label
end


-- [[ SCRIPT LOGIC AND FIXES ]] --

local function updateToolCache()
    Data.toolCache = {}
    local toolCount = 0
    local containers = {player.Character, player:FindFirstChild("Backpack")}

    for _, c in pairs(containers) do
        if c then
            for _, t in pairs(c:GetChildren()) do
                if t:IsA("Tool") and t:FindFirstChild("Handle") then
                    table.insert(Data.toolCache, t.Handle)
                    toolCount = toolCount + 1
                end
            end
        end
    end
    if statLabels.tools then
        statLabels.tools.Text = "Tools: " .. toolCount
        statLabels.tools.TextColor3 = toolCount > 0 and Theme.success or Theme.danger
    end
end

local function getTools()
    if #Data.toolCache == 0 then
        updateToolCache()
        local l = workspace:FindFirstChild("load")
        if l and l:FindFirstChild("RemoteEvent") then
            pcall(function() l.RemoteEvent:FireServer() end)
            task.wait(0.1)
            updateToolCache()
        end
    end
    return Data.toolCache
end

-- Patched findPlayer to correctly identify the command source ('me', 'others', etc.)
local function findPlayer(n, sourcePlayer)
    sourcePlayer = sourcePlayer or player
    if not n or n == "" then return nil end
    n = n:lower()

    if n == "me" then return sourcePlayer end
    if n == "all" then return Players:GetPlayers() end
    if n == "others" or n == "other" then
        local o = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= sourcePlayer then table.insert(o, p) end
        end
        return o
    end

    for _, p in pairs(Players:GetPlayers()) do
        if p.Name:lower() == n or p.DisplayName:lower() == n then
            return p
        end
    end

    for _, p in pairs(Players:GetPlayers()) do
        if p.Name:lower():find(n, 1, true) or p.DisplayName:lower():find(n, 1, true) then
            return p
        end
    end
    return nil
end

local function killPlayer(t)
	if not t or not t.Character or not t.Character:FindFirstChildOfClass("Humanoid") or t.Character.Humanoid.Health <= 0 then
		return false
	end

	if t == player then
		t.Character.Humanoid.Health = 0
		return true
	end

	local tools = getTools()
	if #tools == 0 then return false end
	local tool = #tools > 1 and tools[2] or tools[1]

	if tool and tool.Parent then
		local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
		if r then
			pcall(function() r:FireServer(t.Character.Humanoid, math.huge) end)
			return true
		end
	end
	return false
end

local function godPlayer(t)
    local tools = getTools()
    if #tools == 0 then return false end
    local targets = type(t) == "table" and t or {t}
    local tool = tools[1]

    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            for _, p in pairs(targets) do
                if p and p.Character then
                    local h = p.Character:FindFirstChildOfClass("Humanoid")
                    if h then
                        pcall(function() r:FireServer(h, -math.huge) end)
                    end
                end
            end
            return true
        end
    end
    return false
end

local function healPlayer(t)
    local tools = getTools()
    if #tools == 0 then return false end
    local targets = type(t) == "table" and t or {t}
    local tool = tools[1]

    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            for _, p in pairs(targets) do
                if p and p.Character then
                    local h = p.Character:FindFirstChildOfClass("Humanoid")
                    if h and h.Health < h.MaxHealth then
                        local healAmount = h.MaxHealth - h.Health
                        Stats.healsGiven = Stats.healsGiven + 1
                        pcall(function()
                            for i = 1, 3 do
                                r:FireServer(h, -(healAmount / 3))
                                task.wait()
                            end
                        end)
                    end
                end
            end
            return true
        end
    end
    return false
end

-- Patched damagePlayer to correctly handle decimals from the 'dmg' command
local function damagePlayer(t, damageAmount)
    if not t or not t.Character then return false end
    local h = t.Character:FindFirstChildOfClass("Humanoid")
    if not h or h.Health <= 0 then return false end

    local tools = getTools()
    if #tools == 0 then return false end
    local tool = tools[1]

    if tool and tool.Parent then
        local r = tool:FindFirstChild("dmg") and tool.dmg:FindFirstChild("RemoteEvent")
        if r then
            pcall(function() r:FireServer(h, damageAmount) end)
            return true
        end
    end
    return false
end

local function setupReverseDamage()
    if Data.reverseDmgConnection then Data.reverseDmgConnection:Disconnect() end
    if not State.reverseDmg or not player.Character then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local lastHealth = humanoid.Health
    local lastDamageTime = 0

    Data.reverseDmgConnection = humanoid.HealthChanged:Connect(function(newHealth)
        if not State.reverseDmg then return end

        if newHealth < lastHealth and newHealth > 0 then
            local currentTime = tick()
            local damage = lastHealth - newHealth
            Stats.damageReceived = Stats.damageReceived + damage

            if currentTime - lastDamageTime < 0.1 then return end
            lastDamageTime = currentTime

            task.spawn(function()
                local closestAttacker = nil
                local closestDistance = 30
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    for _, p in pairs(Players:GetPlayers()) do
                        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                            local dist = (p.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                            if dist < closestDistance then
                                closestDistance = dist
                                closestAttacker = p
                            end
                        end
                    end
                end

                healPlayer(player)
                playSound("shield")

                if closestAttacker then
                    killPlayer(closestAttacker)
                    notification("Reversed: Healed & eliminated " .. closestAttacker.DisplayName, 3, "combat")
                else
                    notification("Reversed damage: Healed", 2, "success")
                end
            end)
        end
        lastHealth = newHealth
    end)

    humanoid.Died:Connect(function()
        if State.reverseDmg then
            local creatorTag = humanoid:FindFirstChild("creator")
            if creatorTag and creatorTag.Value then
                notification("Eliminated by: " .. creatorTag.Value.Name, 4, "error")
            end
            Stats.deaths = Stats.deaths + 1
            Stats.killStreak = 0
            notification("Reverse damage will reactivate on respawn.", 2, "info")
        end
    end)
end

-- Patched UI scale input to correctly handle decimals
scaleInput.FocusLost:Connect(function(enterPressed)
    if not (enterPressed and canExecuteInput("scaleChange", "command")) then return end
    if not screenGui or not screenGui.Parent then return end

    local cleanText = string.gsub(scaleInput.Text, "%%", "")
    local newScalePercent = tonumber(cleanText)

    if newScalePercent then
        local newScale = math.clamp(newScalePercent / 100, UIScale.minScale, UIScale.maxScale)
        UIScale.userScale = newScale
        scaleInput.Text = tostring(math.floor(newScale * 100 + 0.5)) .. "%"
        
        task.spawn(function()
            pcall(function()
                rescaleUI()
                notification("UI scale set to " .. math.floor(newScale * 100 + 0.5) .. "%", 2, "success")
            end)
        end)
    else
        scaleInput.Text = tostring(math.floor(UIScale.userScale * 100 + 0.5)) .. "%"
        notification("Invalid scale value. Enter a number.", 2, "warning")
    end
end)

-- Patched startLoopKill to respect execution order
local function startLoopKill(targets, sourcePlayer)
    if State.loopKillActive then
        stopLoopKill()
    end
    if not targets then return end

    State.loopKillActive = true
    
    local targetList = type(targets) == "table" and targets or {targets}
    local others_list = {}
    local self_target = nil
    
    for _, p in pairs(targetList) do
        if p == sourcePlayer then
            self_target = p
        else
            table.insert(others_list, p)
        end
    end
    
    local finalTargetList = others_list
    if self_target then
        table.insert(finalTargetList, self_target) -- Add self to the end of the list
    end

    local connection = Services.Run.Heartbeat:Connect(function()
        if not State.loopKillActive then return end
        for _, target in pairs(finalTargetList) do
            if target then
                task.spawn(killPlayer, target)
            end
        end
        task.wait(0.5)
    end)

    table.insert(State.loopKillConnections, connection)
    notification("Loop kill activated on " .. #finalTargetList .. " targets", 3, "success")
end

local function stopLoopKill()
    if State.loopKillActive then
        for _, conn in pairs(State.loopKillConnections) do
            if conn then conn:Disconnect() end
        end
        State.loopKillConnections = {}
        State.loopKillActive = false
        notification("Loop kill deactivated", 2, "info")
    end
end

local function farm(speed)
    if not player.Character then return end
    local tools = getTools()
    for _, h in pairs(tools) do
        if h and h.Parent then
            local r = h:FindFirstChild("up") and h.up:FindFirstChild("RemoteEvent")
            if r then
                pcall(function()
                    for i = 1, speed do
                        r:FireServer()
                        task.wait()
                    end
                end)
            end
        end
    end
end

local function watchPlayer(targetName)
    local target = findPlayer(targetName)
    if not target or type(target) == "table" then
        notification("Player not found: " .. tostring(targetName), 2, "error")
        return
    end

    if Data.watchConnection then
        Data.watchConnection:Disconnect()
        Data.watchConnection = nil
        State.watchingPlayer = nil
    end

    State.watchingPlayer = target
    notification("Monitoring " .. target.DisplayName, 3, "success")

    Data.watchConnection = Services.Run.Heartbeat:Connect(function()
        if not State.watchingPlayer or not State.watchingPlayer.Character then
            if Data.watchConnection then
                Data.watchConnection:Disconnect()
                Data.watchConnection = nil
                State.watchingPlayer = nil
                if statLabels.watchPlayer then
                    statLabels.watchPlayer.Text = "No player monitored"
                    statLabels.watchPlayer.TextColor3 = Theme.warning
                    statLabels.watchStats.Text = ""
                end
            end
            return
        end

        local char = State.watchingPlayer.Character
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        local rootPart = char:FindFirstChild("HumanoidRootPart")

        if humanoid and rootPart and statLabels.watchPlayer then
            local health = math.floor(humanoid.Health)
            local maxHealth = math.floor(humanoid.MaxHealth)

            local targetPower = 0
            local targetKills = 0
            local ls = State.watchingPlayer:FindFirstChild("leaderstats")
            if ls then
                for _, n in ipairs({"Power", "Strength", "Energy", "Points", "Coins"}) do
                    local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
                    if s then targetPower = tonumber(s.Value) or 0 break end
                end
                for _, n in ipairs({"Kills", "KOs", "Eliminations"}) do
                    local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
                    if s then targetKills = tonumber(s.Value) or 0 break end
                end
            end

            local toolCount = 0
            local containers = {char, State.watchingPlayer:FindFirstChild("Backpack")}
            for _, c in pairs(containers) do
                if c then
                    for _, t in pairs(c:GetChildren()) do
                        if t:IsA("Tool") then
                            toolCount = toolCount + 1
                        end
                    end
                end
            end

            statLabels.watchPlayer.Text = State.watchingPlayer.DisplayName
            statLabels.watchPlayer.TextColor3 = Theme.success

            statLabels.watchStats.Text = string.format("Health %s/%s | Power %s | Kills %s | Tools %d",
                formatNumber(health), formatNumber(maxHealth), formatNumber(targetPower), formatNumber(targetKills), toolCount)
            statLabels.watchStats.TextColor3 = Theme.text
        end
    end)
end

local function protectPlayer(targetName)
    local target = findPlayer(targetName)
    if not target or type(target) == "table" then
        notification("Player not found: " .. tostring(targetName), 2, "error")
        return
    end

    if Data.protectionConnection then
        Data.protectionConnection:Disconnect()
        Data.protectionConnection = nil
    end
    if Data.protectedPlayerConnection then
        Data.protectedPlayerConnection:Disconnect()
        Data.protectedPlayerConnection = nil
    end

    State.protectedPlayer = target
    State.protectionActive = true
    notification("Protection enabled for " .. target.DisplayName, 3, "success")
    playSound("shield")

    if statLabels.protectionPlayer then
        statLabels.protectionPlayer.Text = target.DisplayName
        statLabels.protectionPlayer.TextColor3 = Theme.protection
        statLabels.protectionStats.Text = "Shield enabled - Monitoring for damage"
        statLabels.protectionStats.TextColor3 = Theme.heal
    end

    local function setupProtection(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        local lastHealth = humanoid.Health
        local lastAttackTime = 0

        Data.protectionConnection = humanoid.HealthChanged:Connect(function(newHealth)
            if not State.protectionActive or State.protectedPlayer ~= target then return end

            if newHealth < lastHealth then
                local currentTime = tick()

                if currentTime - lastAttackTime < 1 then return end
                lastAttackTime = currentTime

                task.spawn(function()
                    healPlayer(target)
                    playSound("shield")

                    local closestAttacker = nil
                    local closestDistance = 30

                    if character and character:FindFirstChild("HumanoidRootPart") then
                        for _, p in pairs(Players:GetPlayers()) do
                            if p ~= target and p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                local hasTool = false
                                for _, child in pairs(p.Character:GetChildren()) do
                                    if child:IsA("Tool") then
                                        hasTool = true
                                        break
                                    end
                                end

                                if hasTool then
                                    local distance = (p.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
                                    if distance < closestDistance then
                                        closestDistance = distance
                                        closestAttacker = p
                                    end
                                end
                            end
                        end
                    end

                    if closestAttacker then
                        killPlayer(closestAttacker)
                        notification("Protected: Healed " .. target.DisplayName .. " and eliminated " .. closestAttacker.DisplayName, 3, "combat")
                    else
                        notification("Protected: Healed " .. target.DisplayName, 2, "success")
                    end
                end)
            end

            lastHealth = newHealth
        end)

        humanoid.Died:Connect(function()
            if State.protectionActive and State.protectedPlayer == target then
                Stats.deaths = Stats.deaths + 1
                Stats.killStreak = 0
                notification("Protection failed: " .. target.DisplayName .. " was eliminated", 5, "error")
                playSound("error")
            end
        end)
    end

    if target.Character then
        setupProtection(target.Character)
    end

    Data.protectedPlayerConnection = target.CharacterAdded:Connect(function(character)
        task.wait(1)
        setupProtection(character)
    end)
end

local function stopProtection()
    if Data.protectionConnection then
        Data.protectionConnection:Disconnect()
        Data.protectionConnection = nil
    end
    if Data.protectedPlayerConnection then
        Data.protectedPlayerConnection:Disconnect()
        Data.protectedPlayerConnection = nil
    end

    State.protectedPlayer = nil
    State.protectionActive = false

    if statLabels.protectionPlayer then
        statLabels.protectionPlayer.Text = "No player protected"
        statLabels.protectionPlayer.TextColor3 = Theme.warning
        statLabels.protectionStats.Text = ""
    end

    notification("Protection deactivated", 2, "info")
end

local function toggleSpeedHack(enabled, speed)
    if Data.speedConnections then
        for _, conn in pairs(Data.speedConnections) do
            if conn then conn:Disconnect() end
        end
        Data.speedConnections = {}
    end

    State.speedHack = enabled

    if enabled and player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = speed or 50
            table.insert(Data.speedConnections, humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                if State.speedHack then
                    humanoid.WalkSpeed = speed or 50
                end
            end))
        end
    elseif player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Config.walkSpeed
        end
    end
end

local powerHistory = {}

local function updateStats()
    if not player.Character then return end
    local currentTime = tick()
    local sessionTime = currentTime - Stats.sessionStartTime

    local ls = player:FindFirstChild("leaderstats")
    if ls then
        for _, n in ipairs({"Power", "Strength", "Energy", "Points", "Coins"}) do
            local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
            if s then Stats.power = tonumber(s.Value) or 0 break end
        end
        for _, n in ipairs({"Kills", "KOs", "Eliminations"}) do
            local s = ls:FindFirstChild(n) or ls:FindFirstChild(n:lower())
            if s then
                local newKills = tonumber(s.Value) or 0
                if newKills > Stats.kills then
                    Stats.killStreak = Stats.killStreak + (newKills - Stats.kills)
                    Stats.bestKillStreak = math.max(Stats.bestKillStreak, Stats.killStreak)
                end
                Stats.kills = newKills
                break
            end
        end
    end

    if State.fastFarm or State.slowFarm then
        Stats.powerGainedThisSession = Stats.power - Stats.basePower

        table.insert(powerHistory, {time = currentTime, power = Stats.power})
        if #powerHistory > 10 then table.remove(powerHistory, 1) end

        if #powerHistory >= 2 then
            local td = powerHistory[#powerHistory].time - powerHistory[1].time
            local pd = powerHistory[#powerHistory].power - powerHistory[1].power
            if td > 0 then
                Stats.powerPerSecond = pd / td
                Stats.powerPerHour = Stats.powerPerSecond * 3600
            end
        end

        Stats.farmingTime = Stats.farmingTime + 0.05
    end

    local h = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if h then
        Stats.health = math.floor(h.Health)
        if State.godMode then
            statLabels.health.Text = "Health: ∞"
            statLabels.health.TextColor3 = Theme.glow
        else
            local maxHealth = math.floor(h.MaxHealth)
            local currentHealth = math.floor(h.Health)
            local hp = math.floor((currentHealth / maxHealth) * 100)
            statLabels.health.Text = string.format("Health: %s/%s", formatNumber(currentHealth), formatNumber(maxHealth))
            statLabels.health.TextColor3 = hp <= 25 and Theme.danger or hp <= 50 and Theme.warning or hp <= 75 and Theme.text or Theme.success
        end
    end

    statLabels.power.Text = "Power: " .. formatNumber(Stats.power)
    statLabels.kills.Text = "Kills: " .. formatNumber(Stats.kills)
    statLabels.pph.Text = "Power/hr: " .. formatNumber(Stats.powerPerHour)
    statLabels.session.Text = "Session: +" .. formatNumber(Stats.powerGainedThisSession)
    statLabels.fps.Text = "FPS: " .. Performance.fps
    statLabels.ping.Text = "Ping: " .. (Performance.ping > 0 and Performance.ping .. "ms" or "N/A")
    statLabels.accuracy.Text = "Accuracy: " .. Stats.accuracy .. "%"
    statLabels.killStreak.Text = "Kill Streak: " .. Stats.killStreak
    statLabels.killStreak.TextColor3 = Stats.killStreak >= 10 and Theme.success or Stats.killStreak >= 5 and Theme.warning or Theme.text
    statLabels.bestStreak.Text = "Best: " .. Stats.bestKillStreak
    statLabels.deaths.Text = "Deaths: " .. Stats.deaths
    statLabels.damageDealt.Text = "Damage Dealt: " .. formatNumber(Stats.damageDealt)
    statLabels.damageReceived.Text = "Damage Taken: " .. formatNumber(Stats.damageReceived)
    statLabels.healsGiven.Text = "Heals Given: " .. Stats.healsGiven
    statLabels.farmingTime.Text = "Farm Time: " .. formatTime(Stats.farmingTime)
    statLabels.time.Text = "Session: " .. formatTime(sessionTime)
    statLabels.commands.Text = "Commands: " .. Stats.totalCommands

    local eff = "Calculating..."
    local ec = Theme.accent
    if State.fastFarm or State.slowFarm then
        local farmSpeed = State.fastFarm and Config.speed or 3
        if Stats.powerPerHour >= 1e6 then eff, ec = "Exceptional", Theme.glowSecondary
        elseif Stats.powerPerHour >= 5e5 then eff, ec = "Strong", Theme.success
        elseif Stats.powerPerHour >= 1e5 then eff, ec = "Good", Theme.success
        else eff, ec = "Active", Theme.warning end
        eff = eff .. " (Speed: " .. farmSpeed .. " | " .. formatNumber(Stats.powerPerHour) .. "/hr)"
    else
        eff, ec = "Farming disabled", Theme.danger
    end
    statLabels.eff.Text = "Efficiency: " .. eff
    statLabels.eff.TextColor3 = ec

    local playerCount = #Players:GetPlayers()
    local serverAge = math.floor(workspace.DistributedGameTime / 60)
    local memoryMB = 0

    local memStats = Services.Stats:FindFirstChild("PerformanceStats")
    if memStats then
        pcall(function()
            memoryMB = math.floor((memStats:FindFirstChild("Lua Memory") and memStats["Lua Memory"]:GetValue() or 0) / 1048576)
        end)
    end

    if statLabels.serverStats then
        statLabels.serverStats.Text = string.format("Players: %d | Server Age: %dm | Memory: %dMB",
            playerCount, serverAge, memoryMB)
    end
end

local showCommandsUI
local cmds = {
    {"cmds", "Display the list of commands", function()
        if showCommandsUI then showCommandsUI() end
    end},
    {"scale [percent]", "Set UI scale between 60% and 140%", function(args)
        local scalePercent = tonumber(args[2])
        if scalePercent then
            local newScale = math.clamp(scalePercent / 100, UIScale.minScale, UIScale.maxScale)
            UIScale.userScale = newScale
            scaleInput.Text = tostring(math.floor(newScale * 100 + 0.5)) .. "%"
            rescaleUI()
            notification("UI scale set to " .. math.floor(newScale * 100 + 0.5) .. "%", 2, "success")
        else
            notification("Usage: ;scale [60-140] (example: ;scale 85.5)", 3, "warning")
        end
    end},
    -- [FIX] Command handler for 'admin' with group support
    {"admin [player/all/others]", "Grant command admin to players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found: " .. tostring(args[2]), 2, "error")
            return
        end

        if type(targets) == "table" then
            local count = 0
            for _, p in pairs(targets) do
                if p ~= player and not table.find(Data.adminPlayers, p.Name) then
                    table.insert(Data.adminPlayers, p.Name)
                    count = count + 1
                end
            end
            notification("Admin granted to " .. count .. " players", 3, "success")
        else
            if targets ~= player and not table.find(Data.adminPlayers, targets.Name) then
                table.insert(Data.adminPlayers, targets.Name)
                notification("Admin granted to " .. targets.DisplayName, 3, "success")
            elseif targets == player then
                notification("You are the owner.", 2, "info")
            else
                notification(targets.DisplayName .. " is already an admin.", 2, "info")
            end
        end
    end},
    -- [FIX] Command handler for 'unadmin' with group support
    {"unadmin [player/all/others]", "Revoke command admin from players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found: " .. tostring(args[2]), 2, "error")
            return
        end

        local function revokeAdmin(targetPlayer)
            if targetPlayer == player then return false end
            local foundIndex
            for i, name in ipairs(Data.adminPlayers) do
                if name == targetPlayer.Name then
                    foundIndex = i
                    break
                end
            end
            if foundIndex then
                table.remove(Data.adminPlayers, foundIndex)
                return true
            end
            return false
        end

        if type(targets) == "table" then
            local count = 0
            for _, p in pairs(targets) do
                if revokeAdmin(p) then
                    count = count + 1
                end
            end
            notification("Admin revoked from " .. count .. " players", 3, "success")
        else
            if revokeAdmin(targets) then
                notification("Admin revoked from " .. targets.DisplayName, 3, "success")
            else
                notification("Could not revoke admin from " .. targets.DisplayName, 2, "error")
            end
        end
    end},
    {"tp/to [player]", "Teleport to a player", function(args, sourcePlayer)
        local t = findPlayer(args[2], sourcePlayer)
        if t and type(t) ~= "table" and t.Character and sourcePlayer.Character then
            sourcePlayer.Character.HumanoidRootPart.CFrame = t.Character.HumanoidRootPart.CFrame
            notification("Teleported to " .. t.DisplayName, 2, "success")
        else
            notification("Player not found or character missing.", 2, "error")
        end
    end},
    {"kill [player/all/others/me]", "Eliminate players", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found: " .. tostring(args[2]), 2, "error")
            return
        end

        if type(targets) == "table" then
            local others_list, self_target, count = {}, nil, 0
            for _, p in pairs(targets) do
                if p == sourcePlayer then self_target = p else table.insert(others_list, p) end
            end

            for _, p in pairs(others_list) do
                if killPlayer(p) then count = count + 1 end
                task.wait()
            end
            if self_target and killPlayer(self_target) then count = count + 1 end
            
            notification("Eliminated " .. count .. " players", 2, "success")
        else
            if killPlayer(targets) then
                notification("Eliminated " .. targets.DisplayName, 2, "success")
            end
        end
    end},
    -- [FIX] Command handler for 'dmg' with group support and correct execution order
    {"dmg [player/all/others] [percent]", "Apply damage to players (accepts decimals)", function(args, sourcePlayer)
        local targetName = args[2]
        local damagePercent = tonumber(args[3])

        if not targetName or not damagePercent then
            notification("Usage: ;dmg [target] [percent] (e.g., ;dmg all 50.5)", 3, "warning")
            return
        end

        local targets = findPlayer(targetName, sourcePlayer)
        if not targets then
            notification("Target not found: " .. targetName, 2, "error")
            return
        end
        
        local function applyDamage(target)
            if target and target.Character and target.Character:FindFirstChildOfClass("Humanoid") then
                local h = target.Character.Humanoid
                local damageAmount = (damagePercent / 100) * h.MaxHealth
                return damagePlayer(target, damageAmount)
            end
            return false
        end

        if type(targets) == "table" then
            local others_list, self_target, count = {}, nil, 0
            for _, p in pairs(targets) do
                if p == sourcePlayer then self_target = p else table.insert(others_list, p) end
            end
            
            for _, p in pairs(others_list) do
                if applyDamage(p) then count = count + 1 end
                task.wait()
            end
            if self_target and applyDamage(self_target) then count = count + 1 end
            
            notification(string.format("Applied %.1f%% damage to %d players", damagePercent, count), 3, "success")
        else
            if applyDamage(targets) then
                notification(string.format("Applied %.1f%% damage to %s", damagePercent, targets.DisplayName), 3, "success")
            else
                notification("Failed to apply damage to " .. targets.DisplayName, 2, "error")
            end
        end
    end},
    {"loopkill [player/all/others/me]", "Continuously eliminate target(s)", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if targets then
            startLoopKill(targets, sourcePlayer)
        else
            notification("Player not found: " .. tostring(args[2]), 2, "error")
        end
    end},
    {"unloopkill/stoploopkill", "Deactivate loop kill", function()
        stopLoopKill()
    end},
    {"god [player/all/others/me]", "Activate god mode", function(args, sourcePlayer)
        local targets = findPlayer(args[2] or "me", sourcePlayer)
        if not targets then
            notification("Player not found: " .. tostring(args[2]), 2, "error")
            return
        end
        
        if type(targets) == "table" then
            local others_list, self_target = {}, nil
            for _, p in pairs(targets) do
                if p == sourcePlayer then self_target = p else table.insert(others_list, p) end
            end

            if #others_list > 0 then godPlayer(others_list) end
            if self_target then godPlayer(self_target) end
        else
            godPlayer(targets)
        end
        notification("God mode activated.", 2, "success")
    end},
    {"heal [me/other/all/player]", "Restore health to full for players", function(args, sourcePlayer)
        local t = findPlayer(args[2] or "me", sourcePlayer)
        if t then
            if type(t) == "table" then
                local healedCount = 0
                for _, p in pairs(t) do
                    if p and healPlayer(p) then
                        healedCount = healedCount + 1
                    end
                    task.wait()
                end
                notification("Restored health for " .. healedCount .. " players", 3, "success")
            else
                if healPlayer(t) then
                    local displayName = t == sourcePlayer and "yourself" or t.DisplayName
                    notification("Restored health for " .. displayName, 2, "success")
                else
                    notification("Failed to restore health for " .. (t == sourcePlayer and "yourself" or t.DisplayName), 2, "error")
                end
            end
        else
            notification("Player not found: " .. tostring(args[2]), 2, "error")
        end
    end},
    {"protect [player]", "Protect a player by healing on damage", function(args)
        if not args[2] then
            notification("Usage: ;protect [player name]", 3, "warning")
            return
        end
        protectPlayer(args[2])
    end},
    {"unprotect", "Deactivate protection for current player", function()
        stopProtection()
    end},
    {"reversedmg", "Toggle reverse damage to heal on damage", function()
        State.reverseDmg = not State.reverseDmg
        if State.reverseDmg then
            setupReverseDamage()
            notification("Reverse damage activated - Heal on damage", 3, "success")
        else
            if Data.reverseDmgConnection then
                Data.reverseDmgConnection:Disconnect()
                Data.reverseDmgConnection = nil
            end
            notification("Reverse damage deactivated", 2, "info")
        end
    end},
    {"fly", "Toggle flight mode", function(args, sourcePlayer)
        if sourcePlayer ~= player then
            notification("Only the script owner can use flight.", 2, "error")
            return
        end
        State.flying = not State.flying
        notification("Flight " .. (State.flying and "activated" or "deactivated"), 2, "info")
        if Data.flyConnection then Data.flyConnection:Disconnect(); Data.flyConnection = nil end
        if Data.charDiedFlyConnection then Data.charDiedFlyConnection:Disconnect(); Data.charDiedFlyConnection = nil end
        if Data.flyObjects then
            for _, v in pairs(Data.flyObjects) do if v and v.Parent then v:Destroy() end end
            Data.flyObjects = {}
        end
        if player.Character then
            local h = player.Character:FindFirstChildOfClass("Humanoid")
            if h then h.PlatformStand = false end
        end
        if not State.flying then return end
        local char = player.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then
            notification("Cannot activate flight without a character.", 2, "error")
            State.flying = false
            return
        end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        local rootPart = char.HumanoidRootPart
        humanoid.PlatformStand = true
        local bv = Instance.new("BodyVelocity", rootPart)
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new(0, 0, 0)
        local bg = Instance.new("BodyGyro", rootPart)
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.D = 100
        bg.P = 10000
        bg.CFrame = rootPart.CFrame
        Data.flyObjects = {bv = bv, bg = bg}
        Data.flyConnection = Services.Run.Heartbeat:Connect(function()
            if not State.flying or not Data.flyObjects.bv or not Data.flyObjects.bv.Parent then
                if Data.flyConnection then Data.flyConnection:Disconnect(); Data.flyConnection = nil end
                return
            end
            local cam = workspace.CurrentCamera
            local moveVector = Vector3.new(0, 0, 0)
            if Services.UIS:IsKeyDown(Enum.KeyCode.W) then moveVector = moveVector + cam.CFrame.LookVector end
            if Services.UIS:IsKeyDown(Enum.KeyCode.S) then moveVector = moveVector - cam.CFrame.LookVector end
            if Services.UIS:IsKeyDown(Enum.KeyCode.A) then moveVector = moveVector - cam.CFrame.RightVector end
            if Services.UIS:IsKeyDown(Enum.KeyCode.D) then moveVector = moveVector + cam.CFrame.RightVector end
            if Services.UIS:IsKeyDown(Enum.KeyCode.Space) then moveVector = moveVector + Vector3.new(0, 1, 0) end
            if Services.UIS:IsKeyDown(Enum.KeyCode.LeftShift) then moveVector = moveVector - Vector3.new(0, 1, 0) end
            if moveVector.Magnitude > 0 then
                Data.flyObjects.bv.Velocity = moveVector.Unit * Config.flySpeed
            else
                Data.flyObjects.bv.Velocity = Vector3.new(0, 0, 0)
            end
            Data.flyObjects.bg.CFrame = cam.CFrame
        end)

        Data.charDiedFlyConnection = humanoid.Died:Connect(function()
            State.flying = false
            notification("Flight deactivated due to death.", 2, "info")
            if Data.flyConnection then Data.flyConnection:Disconnect(); Data.flyConnection = nil end
            if Data.charDiedFlyConnection then Data.charDiedFlyConnection:Disconnect(); Data.charDiedFlyConnection = nil end
        end)
    end},
    {"unfly", "Deactivate flight", function(args, sourcePlayer)
        if sourcePlayer ~= player then return end
        if State.flying then
            State.flying = false
            if Data.flyConnection then Data.flyConnection:Disconnect(); Data.flyConnection = nil end
            if Data.charDiedFlyConnection then Data.charDiedFlyConnection:Disconnect(); Data.charDiedFlyConnection = nil end
            if Data.flyObjects then
                for _, v in pairs(Data.flyObjects) do if v and v.Parent then v:Destroy() end end
                Data.flyObjects = {}
            end
            if player.Character then
                local h = player.Character:FindFirstChildOfClass("Humanoid")
                if h then h.PlatformStand = false end
            end
            notification("Flight deactivated", 2, "info")
        else
            notification("Flight is already deactivated", 2, "info")
        end
    end},
    {"noclip", "Toggle no-clip mode", function(args, sourcePlayer)
        if sourcePlayer ~= player then notification("Noclip is owner-only.", 2, "error") return end
        State.noclip = not State.noclip
        notification("No-clip " .. (State.noclip and "activated" or "deactivated"), 2, "info")
        if State.noclip then
            Data.noclipConnection = Services.Run.Stepped:Connect(function()
                if player.Character then
                    for _, p in pairs(player.Character:GetDescendants()) do
                        if p:IsA("BasePart") and p.CanCollide then p.CanCollide = false end
                    end
                end
            end)
        else
            if Data.noclipConnection then Data.noclipConnection:Disconnect(); Data.noclipConnection = nil end
        end
    end},
    {"unnoclip", "Deactivate no-clip", function(args, sourcePlayer)
        if sourcePlayer ~= player then return end
        if State.noclip then
            State.noclip = false
            if Data.noclipConnection then Data.noclipConnection:Disconnect(); Data.noclipConnection = nil end
            notification("No-clip deactivated", 2, "info")
        else
            notification("No-clip is already deactivated", 2, "info")
        end
    end},
    {"speed/ws [num]", "Set walking speed", function(args, sourcePlayer)
        if sourcePlayer ~= player then notification("Speed is owner-only.", 2, "error") return end
        local s = tonumber(args[2]) or 16
        toggleSpeedHack(s ~= 16, s)
        notification("Walking speed set to " .. s, 2, "success")
    end},
    {"unspeed", "Reset walking speed to default", function(args, sourcePlayer)
        if sourcePlayer ~= player then return end
        toggleSpeedHack(false)
        notification("Walking speed reset to default", 2, "info")
    end},
    {"watch [player]", "Monitor a player's statistics", function(args)
        if not args[2] then
            notification("Usage: ;watch [player name]", 3, "warning")
            return
        end
        watchPlayer(args[2])
    end},
    {"unwatch", "Stop monitoring player", function()
        if Data.watchConnection then
            Data.watchConnection:Disconnect()
            Data.watchConnection = nil
            State.watchingPlayer = nil
            if statLabels.watchPlayer then
                statLabels.watchPlayer.Text = "No player monitored"
                statLabels.watchPlayer.TextColor3 = Theme.warning
                statLabels.watchStats.Text = ""
            end
            notification("Stopped monitoring player", 2, "info")
        else
            notification("No player is being monitored", 2, "info")
        end
    end},
    {"reset", "Reset your character", function(args, sourcePlayer)
        if sourcePlayer.Character then
            local h = sourcePlayer.Character:FindFirstChildOfClass("Humanoid")
            if h then h.Health = 0 end
        end
    end}
}

-- Patched command execution to pass the source player
local function executeCmd(cmd, sourcePlayer)
    sourcePlayer = sourcePlayer or player
    if not canExecuteInput("executeCmd", "command") then return end
    if not cmd or cmd == "" then return end
    if cmd:sub(1, 1) == Config.commandPrefix then cmd = cmd:sub(2) end

    local args = {}
    for a in cmd:gmatch("%S+") do table.insert(args, a) end
    if #args == 0 then return end

    local cmdName = args[1]:lower()
    Stats.totalCommands = Stats.totalCommands + 1

    for _, c in ipairs(cmds) do
        local cmdPattern = c[1]:split(" ")[1]
        local found = false
        if cmdPattern:find("/") then
            for alt in cmdPattern:gmatch("[^/]+") do
                if alt == cmdName then found = true; break end
            end
        elseif cmdPattern == cmdName then
            found = true
        end
        if found then
            playSound("click")
            pcall(c[3], args, sourcePlayer)
            return
        end
    end
    notification("Unknown command: " .. cmdName, 2, "error")
end

local function createToggle(text, callback, showSpeed)
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1, -S(6), 0, S(isMobile and 45 or 55))
    f.BackgroundColor3 = Theme.tertiary
    f.BackgroundTransparency = 0.6
    f.Parent = content
    addCornerAndStroke(f, S(8), Theme.glassBorder, S(1))
    createScalableElement(f, UDim2.new(1, -6, 0, isMobile and 45 or 55), nil, nil, 8)

    local l = Instance.new("TextLabel")
    l.Size = UDim2.new(1, showSpeed and -S(isMobile and 110 or 130) or -S(isMobile and 70 or 80), 1, 0)
    l.Position = UDim2.new(0, S(16), 0, 0)
    l.BackgroundTransparency = 1
    l.Text = text
    l.TextColor3 = Theme.text
    l.TextSize = S(isMobile and 11 or 13)
    l.Font = Enum.Font.Gotham
    l.TextXAlignment = Enum.TextXAlignment.Left
    l.Parent = f
    createScalableElement(l,
        UDim2.new(1, showSpeed and -(isMobile and 110 or 130) or -(isMobile and 70 or 80), 1, 0),
        UDim2.new(0, 16, 0, 0), isMobile and 11 or 13)

    local si
    if showSpeed then
        si = Instance.new("TextBox")
        si.Size = UDim2.new(0, S(isMobile and 35 or 45), 0, S(isMobile and 22 or 27))
        si.Position = UDim2.new(1, -S(isMobile and 95 or 105), 0.5, -S(isMobile and 11 or 13.5))
        si.BackgroundColor3 = Theme.secondary
        si.BackgroundTransparency = 0.6
        si.Text = tostring(Config.speed)
        si.TextColor3 = Theme.text
        si.TextSize = S(isMobile and 9 or 11)
        si.Font = Enum.Font.Gotham
        si.Parent = f
        addCornerAndStroke(si, S(5))
        createScalableElement(si,
            UDim2.new(0, isMobile and 35 or 45, 0, isMobile and 22 or 27),
            UDim2.new(1, -(isMobile and 95 or 105), 0.5, -(isMobile and 11 or 13.5)),
            isMobile and 9 or 11, 5)

        si.FocusLost:Connect(function(enterPressed)
            local n = tonumber(si.Text)
            if n and n >= 1 and n <= 100 then
                Config.speed = n
                notification("Farm speed set to " .. n, 2, "success")
            else
                si.Text = tostring(Config.speed)
                notification("Invalid speed. Use 1 to 100.", 2, "warning")
            end
        end)
    end

    local t = Instance.new("TextButton")
    t.Size = UDim2.new(0, S(isMobile and 50 or 60), 0, S(isMobile and 27 or 32))
    t.Position = UDim2.new(1, -S(isMobile and 60 or 70), 0.5, -S(isMobile and 13.5 or 16))
    t.BackgroundColor3 = Theme.danger
    t.BackgroundTransparency = 0.3
    t.Text = "OFF"
    t.TextColor3 = Theme.text
    t.TextSize = S(isMobile and 9 or 11)
    t.Font = Enum.Font.GothamBold
    t.AutoButtonColor = false
    t.Parent = f
    addCornerAndStroke(t, S(6))
    createScalableElement(t,
        UDim2.new(0, isMobile and 50 or 60, 0, isMobile and 27 or 32),
        UDim2.new(1, -(isMobile and 60 or 70), 0.5, -(isMobile and 13.5 or 16)),
        isMobile and 9 or 11, 6)

    local enabled = false

    t.MouseEnter:Connect(function()
        if not canExecuteInput("toggleHover" .. text, "button") then return end
        playSound("hover")
        Services.Tween:Create(t, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.1
        }):Play()
    end)

    t.MouseLeave:Connect(function()
        Services.Tween:Create(t, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.3
        }):Play()
    end)

    t.MouseButton1Click:Connect(function()
        if not canExecuteInput("toggle" .. text, "button") then return end
        enabled = not enabled
        playSound("click")

        Services.Tween:Create(t, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {
            BackgroundColor3 = enabled and Theme.success or Theme.danger,
            Rotation = enabled and 180 or 0
        }):Play()

        t.Text = enabled and "ON" or "OFF"

        callback(enabled)
    end)

    return f, t, si
end

local function createButton(text, callback, color)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, -S(6), 0, S(isMobile and 40 or 50))
    b.BackgroundColor3 = color or Theme.tertiary
    b.BackgroundTransparency = 0.6
    b.Text = text
    b.TextColor3 = Theme.text
    b.TextSize = S(isMobile and 11 or 13)
    b.Font = Enum.Font.GothamBold
    b.AutoButtonColor = false
    b.Parent = content
    addCornerAndStroke(b, S(8), Theme.glassBorder, S(1))
    createScalableElement(b,
        UDim2.new(1, -6, 0, isMobile and 40 or 50), nil,
        isMobile and 11 or 13, 8)

    local btnGrad = Instance.new("UIGradient")
    btnGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, color or Theme.tertiary),
        ColorSequenceKeypoint.new(1, (color or Theme.tertiary):Lerp(Color3.new(0,0,0), 0.15))
    }
    btnGrad.Rotation = 90
    btnGrad.Parent = b

    b.MouseEnter:Connect(function()
        if not canExecuteInput("btnHover" .. text, "button") then return end
        playSound("hover")
        Services.Tween:Create(b, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.4
        }):Play()
        Services.Tween:Create(btnGrad, TweenInfo.new(0.2), {
            Rotation = 270
        }):Play()
    end)

    b.MouseLeave:Connect(function()
        Services.Tween:Create(b, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.6
        }):Play()
        Services.Tween:Create(btnGrad, TweenInfo.new(0.2), {
            Rotation = 90
        }):Play()
    end)

    b.MouseButton1Click:Connect(function()
        if not canExecuteInput("btn" .. text, "button") then return end
        playSound("click")

        Services.Tween:Create(b, TweenInfo.new(0.1), {
            Size = UDim2.new(1, -S(10), 0, S(isMobile and 37 or 47))
        }):Play()

        task.wait(0.1)

        Services.Tween:Create(b, TweenInfo.new(0.2, Enum.EasingStyle.Back), {
            Size = UDim2.new(1, -S(6), 0, S(isMobile and 40 or 50))
        }):Play()

        callback()
    end)

    return b
end

showCommandsUI = function()
    if screenGui:FindFirstChild("CommandsFrame") or not canExecuteInput("showCommands", "command") then return end
    playSound("open")

    local cf = Instance.new("Frame")
    cf.Name = "CommandsFrame"
    cf.Size = UDim2.new(0, S(isMobile and 360 or 460), 0, S(isMobile and 460 or 580))
    cf.Position = UDim2.new(0.5, -S(isMobile and 180 or 230), 0.5, -S(isMobile and 230 or 290))
    cf.BackgroundColor3 = Theme.background
    cf.BackgroundTransparency = 0
    cf.ClipsDescendants = true
    cf.Parent = screenGui
    addCornerAndStroke(cf, S(14), Theme.glassBorder, S(1))

    cf.Size = UDim2.new(0, 0, 0, 0)
    cf.Position = UDim2.new(0.5, 0, 0.5, 0)
    Services.Tween:Create(cf, TweenInfo.new(0.35, Enum.EasingStyle.Back), {
        Size = UDim2.new(0, S(isMobile and 360 or 460), 0, S(isMobile and 460 or 580)),
        Position = UDim2.new(0.5, -S(isMobile and 180 or 230), 0.5, -S(isMobile and 230 or 290))
    }):Play()

    local cfGradient = Instance.new("UIGradient")
    cfGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Theme.background),
        ColorSequenceKeypoint.new(1, Theme.secondary)
    }
    cfGradient.Rotation = 90
    cfGradient.Parent = cf

    local ch = Instance.new("Frame")
    ch.Size = UDim2.new(1, 0, 0, S(isMobile and 45 or 55))
    ch.BackgroundColor3 = Theme.secondary
    ch.BackgroundTransparency = 0.4
    ch.Parent = cf
    makeDraggable(cf, ch)
    addCornerAndStroke(ch, S(14))

    local ct = Instance.new("TextLabel")
    ct.Size = UDim2.new(1, -S(50), 1, 0)
    ct.Position = UDim2.new(0, S(16), 0, 0)
    ct.BackgroundTransparency = 1
    ct.Text = "Command List"
    ct.TextColor3 = Theme.text
    ct.TextSize = S(isMobile and 15 or 19)
    ct.Font = Enum.Font.GothamBold
    ct.TextXAlignment = Enum.TextXAlignment.Left
    ct.Parent = ch

    local ctStroke = Instance.new("UIStroke")
    ctStroke.Color = Theme.accent
    ctStroke.Thickness = S(1)
    ctStroke.Transparency = 0.75
    ctStroke.Parent = ct

    local cx = Instance.new("TextButton")
    cx.Size = UDim2.new(0, S(isMobile and 28 or 38), 0, S(isMobile and 28 or 38))
    cx.Position = UDim2.new(1, -S(isMobile and 36 or 46), 0.5, -S(isMobile and 14 or 19))
    cx.BackgroundColor3 = Theme.danger
    cx.BackgroundTransparency = 0.3
    cx.Text = "X"
    cx.TextColor3 = Theme.text
    cx.TextSize = S(isMobile and 15 or 19)
    cx.Font = Enum.Font.SourceSans
    cx.AutoButtonColor = false
    cx.Parent = ch
    addCornerAndStroke(cx, S(8))

    cx.MouseEnter:Connect(function()
        if not canExecuteInput("cmdCloseHover", "button") then return end
        playSound("hover")
        Services.Tween:Create(cx, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.1,
            Rotation = 90
        }):Play()
    end)

    cx.MouseLeave:Connect(function()
        Services.Tween:Create(cx, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.3,
            Rotation = 0
        }):Play()
    end)

    cx.MouseButton1Click:Connect(function()
        if not canExecuteInput("cmdClose", "button") then return end
        playSound("close")
        Services.Tween:Create(cf, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Size = UDim2.new(0, 0, 0, 0),
            Position = UDim2.new(0.5, 0, 0.5, 0)
        }):Play()
        task.wait(0.25)
        cf:Destroy()
    end)

    local cs = Instance.new("ScrollingFrame")
    cs.Size = UDim2.new(1, -S(12), 1, -S(isMobile and 50 or 60))
    cs.Position = UDim2.new(0, S(6), 0, S(isMobile and 50 or 60))
    cs.BackgroundColor3 = Theme.secondary
    cs.BackgroundTransparency = 0.8
    cs.BorderSizePixel = 0
    cs.ScrollBarThickness = S(isMobile and 2 or 3)
    cs.ScrollBarImageColor3 = Theme.accent
    cs.ScrollBarImageTransparency = 0.5
    cs.AutomaticCanvasSize = Enum.AutomaticSize.Y
    cs.Parent = cf
    addCornerAndStroke(cs, S(10))

    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, S(6))
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Parent = cs

    for i, c in ipairs(cmds) do
        task.spawn(function()
            task.wait(i * 0.02)

            local ci = Instance.new("Frame")
            ci.Size = UDim2.new(1, 0, 0, S(isMobile and 50 or 60))
            ci.BackgroundColor3 = Theme.tertiary
            ci.BackgroundTransparency = 0.6
            ci.LayoutOrder = i
            ci.Parent = cs
            addCornerAndStroke(ci, S(8), Theme.glassBorder, S(1))

            ci.BackgroundTransparency = 1
            Services.Tween:Create(ci, TweenInfo.new(0.25), {
                BackgroundTransparency = 0.6
            }):Play()

            ci.MouseEnter:Connect(function()
                Services.Tween:Create(ci, TweenInfo.new(0.2), {
                    BackgroundTransparency = 0.4
                }):Play()
            end)

            ci.MouseLeave:Connect(function()
                Services.Tween:Create(ci, TweenInfo.new(0.2), {
                    BackgroundTransparency = 0.6
                }):Play()
            end)

            local cn = Instance.new("TextLabel")
            cn.Size = UDim2.new(1, -S(20), 0, S(isMobile and 22 or 27))
            cn.Position = UDim2.new(0, S(12), 0, S(5))
            cn.BackgroundTransparency = 1
            cn.Text = Config.commandPrefix .. c[1]
            cn.TextColor3 = Theme.accent
            cn.TextSize = S(isMobile and 12 or 14)
            cn.Font = Enum.Font.GothamBold
            cn.TextXAlignment = Enum.TextXAlignment.Left
            cn.Parent = ci

            local cd = Instance.new("TextLabel")
            cd.Size = UDim2.new(1, -S(20), 0, S(isMobile and 18 or 23))
            cd.Position = UDim2.new(0, S(12), 0, S(isMobile and 25 or 32))
            cd.BackgroundTransparency = 1
            cd.Text = c[2]
            cd.TextColor3 = Theme.textSecondary
            cd.TextSize = S(isMobile and 10 or 12)
            cd.Font = Enum.Font.Gotham
            cd.TextXAlignment = Enum.TextXAlignment.Left
            cd.Parent = ci
        end)
    end
end

createToggle("Fast Farm", function(e)
    State.fastFarm = e
    if e and State.slowFarm then State.slowFarm = false end

    if State.coroutines.fastFarm then
        task.cancel(State.coroutines.fastFarm)
        State.coroutines.fastFarm = nil
    end

    if e then
        Stats.basePower = Stats.power
        Stats.powerGainedThisSession = 0
        powerHistory = {{time = tick(), power = Stats.power}}
        notification("Fast farm activated (Speed: " .. Config.speed .. ")", 2, "success")

        State.coroutines.fastFarm = task.spawn(function()
            while State.fastFarm do
                farm(Config.speed)
                task.wait(0.1)
            end
        end)
    else
        Stats.powerGainedThisSession = 0
        notification("Fast farm deactivated", 2, "info")
    end
end, true)

createToggle("Slow Farm", function(e)
    State.slowFarm = e
    if e and State.fastFarm then State.fastFarm = false end

    if State.coroutines.slowFarm then
        task.cancel(State.coroutines.slowFarm)
        State.coroutines.slowFarm = nil
    end

    if e then
        Stats.basePower = Stats.power
        Stats.powerGainedThisSession = 0
        powerHistory = {{time = tick(), power = Stats.power}}
        notification("Slow farm activated (Speed: 3)", 2, "success")

        State.coroutines.slowFarm = task.spawn(function()
            while State.slowFarm do
                farm(3)
                task.wait(0.1)
            end
        end)
    else
        Stats.powerGainedThisSession = 0
        notification("Slow farm deactivated", 2, "info")
    end
end)

createToggle("God Mode", function(e)
    State.godMode = e

    if State.coroutines.godMode then
        task.cancel(State.coroutines.godMode)
        State.coroutines.godMode = nil
    end

    notification("God mode " .. (e and "activated" or "deactivated"), 2, e and "success" or "info")

    if e then
        State.coroutines.godMode = task.spawn(function()
            while State.godMode and player.Character do
                godPlayer(player)
                task.wait(1)
            end
        end)
    end
end)

createToggle("Kill Aura", function(e)
    State.killAura = e

    if State.coroutines.killAura then
        task.cancel(State.coroutines.killAura)
        State.coroutines.killAura = nil
    end

    notification("Kill aura " .. (e and "activated" or "deactivated"), 2, e and "success" or "info")

    if e then
        State.coroutines.killAura = task.spawn(function()
            while State.killAura do
                if player.Character then
                    local rp = player.Character:FindFirstChild("HumanoidRootPart")
                    if rp then
                        for _, p in pairs(Players:GetPlayers()) do
                            if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                                if (rp.Position - p.Character.HumanoidRootPart.Position).Magnitude <= Config.range then
                                    task.spawn(killPlayer, p)
                                end
                            end
                        end
                    end
                end
                task.wait(0.5)
            end
        end)
    end
end)

createToggle("Reverse Damage", function(e)
    executeCmd(";reversedmg", player)
end)

createButton("Eliminate All Players", function() executeCmd(";kill all", player) end, Theme.danger)
createButton("God Mode All Players", function() executeCmd(";god all", player) end, Theme.accent)
createButton("Heal All Players", function() executeCmd(";heal all", player) end, Theme.heal)
createButton("Reset Session Statistics", function()
    Stats.powerGainedThisSession = 0
    Stats.sessionStartTime = tick()
    Stats.basePower = Stats.power
    Stats.kills = 0
    Stats.deaths = 0
    Stats.killStreak = 0
    Stats.damageDealt = 0
    Stats.damageReceived = 0
    Stats.healsGiven = 0
    Stats.farmingTime = 0
    Stats.totalCommands = 0
    powerHistory = {}
    notification("Session statistics reset", 3, "success")
end, Theme.info)
createButton("View Commands", showCommandsUI, Theme.accent)

local function showCmd()
    if State.commandBarVisible or not canExecuteInput("showCmd", "command") then return end
    State.commandBarVisible = true
    commandBar.Visible = true

    playSound("open")

    Services.Tween:Create(commandBar, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        {Position = UDim2.new(0.5, -S(isMobile and 180 or 250), 1, -S(isMobile and 70 or 85))}):Play()
    Services.Tween:Create(accentLine, TweenInfo.new(0.5, Enum.EasingStyle.Quart),
        {Size = UDim2.new(1, 0, 0, S(1))}):Play()

    task.spawn(function()
        wait(0.15)
        cmdInput:CaptureFocus()
    end)
end

local function hideCmd()
    if not State.commandBarVisible or not canExecuteInput("hideCmd", "button") then return end
    State.commandBarVisible = false
    cmdInput:ReleaseFocus()

    playSound("close")

    Services.Tween:Create(accentLine, TweenInfo.new(0.15),
        {Size = UDim2.new(0, 0, 0, S(1))}):Play()
    Services.Tween:Create(commandBar, TweenInfo.new(0.25, Enum.EasingStyle.Quart),
        {Position = UDim2.new(0.5, -S(isMobile and 180 or 250), 1, S(100))}):Play()

    task.spawn(function()
        wait(0.25)
        if not State.commandBarVisible then commandBar.Visible = false end
    end)
end

execBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("execBtn", "command") then return end
    playSound("click")
    executeCmd(Config.commandPrefix .. cmdInput.Text, player)
    cmdInput.Text = ""
    hideCmd()
end)

cmdInput.FocusLost:Connect(function(enter)
    if enter and canExecuteInput("cmdEnter", "command") then
        executeCmd(Config.commandPrefix .. cmdInput.Text, player)
        cmdInput.Text = ""
    end
    hideCmd()
end)

Services.UIS.InputBegan:Connect(function(input, gp)
    if gp then return end

    if input.KeyCode == Enum.KeyCode.Semicolon and not cmdInput:IsFocused() then
        if canExecuteInput("semicolon", "command") then
            showCmd()
            task.wait()
            cmdInput.Text = ""
        end
    elseif input.KeyCode == Enum.KeyCode.Escape and State.commandBarVisible then
        hideCmd()
    elseif input.KeyCode == Enum.KeyCode.Insert then
        if canExecuteInput("insert", "command") then
            mainFrame.Visible = not mainFrame.Visible
            playSound(mainFrame.Visible and "open" or "close")
        end
    elseif input.KeyCode == Enum.KeyCode.Minus then
        if canExecuteInput("scaleDown", "button") then
            local newScale = math.clamp(UIScale.userScale - 0.1, UIScale.minScale, UIScale.maxScale)
            UIScale.userScale = newScale
            if scaleInput and scaleInput.Parent then
                scaleInput.Text = tostring(math.floor(newScale * 100 + 0.5)) .. "%"
            end
            task.spawn(function()
                task.wait(0.1)
                if screenGui and screenGui.Parent then
                    rescaleUI()
                    notification("UI scale: " .. math.floor(newScale * 100 + 0.5) .. "%", 1, "info")
                end
            end)
        end
    elseif input.KeyCode == Enum.KeyCode.Equals then
        if canExecuteInput("scaleUp", "button") then
            local newScale = math.clamp(UIScale.userScale + 0.1, UIScale.minScale, UIScale.maxScale)
            UIScale.userScale = newScale
            if scaleInput and scaleInput.Parent then
                scaleInput.Text = tostring(math.floor(newScale * 100 + 0.5)) .. "%"
            end
            task.spawn(function()
                task.wait(0.1)
                if screenGui and screenGui.Parent then
                    rescaleUI()
                    notification("UI scale: " .. math.floor(newScale * 100 + 0.5) .. "%", 1, "info")
                end
            end)
        end
    end
end)

closeBtn.MouseButton1Click:Connect(function()
    if not canExecuteInput("closeBtn", "command") then return end
    playSound("close")

    State.flying = false
    executeCmd(";unfly", player)

    for _, c in pairs(Data.connections) do if c then c:Disconnect() end end
    if Data.noclipConnection then Data.noclipConnection:Disconnect() end
    if Data.reverseDmgConnection then Data.reverseDmgConnection:Disconnect() end
    if Data.watchConnection then Data.watchConnection:Disconnect() end
    if Data.protectionConnection then Data.protectionConnection:Disconnect() end
    if Data.protectedPlayerConnection then Data.protectedPlayerConnection:Disconnect() end
    for _, conn in pairs(Data.speedConnections) do if conn then conn:Disconnect() end end
    for _, conn in pairs(State.loopKillConnections) do if conn then conn:Disconnect() end end

    for _, coroutine in pairs(State.coroutines) do
        if coroutine then task.cancel(coroutine) end
    end

    Services.Tween:Create(mainFrame, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        Rotation = 180
    }):Play()

    task.wait(0.35)

    if Sounds.hover and Sounds.hover.Parent then
        Sounds.hover.Parent:Destroy()
    end

    screenGui:Destroy()
end)

local lastLoop = 0
local updateInterval = 0.05
local mainLoop = Services.Run.Heartbeat:Connect(function()
    local t = tick()
    if t - lastLoop < updateInterval then return end
    lastLoop = t

    pcall(updatePerformanceMetrics)
    pcall(updateStats)
end)

table.insert(Data.connections, mainLoop)

local function onChar(char)
    if not char then return end

    updateToolCache()
    char.ChildAdded:Connect(updateToolCache)
    char.ChildRemoved:Connect(updateToolCache)
    
    local backpack = player:WaitForChild("Backpack")
    backpack.ChildAdded:Connect(updateToolCache)
    backpack.ChildRemoved:Connect(updateToolCache)

    local h = char:WaitForChild("Humanoid", 5)
    if h then
        h.WalkSpeed = State.speedHack and (Config.flySpeed or 50) or Config.walkSpeed
        h.JumpPower = Config.jumpPower

        if State.reverseDmg then setupReverseDamage() end
        if State.speedHack then toggleSpeedHack(true, Config.flySpeed or 50) end

        if State.noclip and Data.noclipConnection then
            Data.noclipConnection:Disconnect()
            Data.noclipConnection = Services.Run.Stepped:Connect(function()
                if player.Character then
                    for _, p in pairs(player.Character:GetDescendants()) do
                        if p:IsA("BasePart") and p.CanCollide then p.CanCollide = false end
                    end
                end
            end)
        end

        if State.godMode then
            task.spawn(function()
                task.wait(1)
                godPlayer(player)
            end)
        end
    end
end

if player.Character then onChar(player.Character) end
player.CharacterAdded:Connect(onChar)

table.insert(Data.adminPlayers, player.Name)
Stats.sessionStartTime = tick()
commandBar.Visible = false

-- Patched chat processing to handle commands from admins correctly
local function processMessage(msg)
    if msg.Text:sub(1, 1) == Config.commandPrefix then
        local sourcePlayer = Players:GetPlayerByUserId(msg.TextSource.UserId)
        if sourcePlayer and (sourcePlayer == player or table.find(Data.adminPlayers, sourcePlayer.Name)) then
            task.spawn(function()
                executeCmd(msg.Text, sourcePlayer)
            end)
            return true
        end
    end
    return false
end

if Services.TextChat and Services.TextChat.ChatVersion == Enum.ChatVersion.TextChatService then
    pcall(function()
        local textChatService = Services.TextChat
        textChatService.OnIncomingMessage = function(message)
            if message.Status ~= Enum.TextChatMessageStatus.Success then return end
            processMessage(message)
        end
    end)
else
    player.Chatted:Connect(function(msg)
        task.spawn(function()
            -- For legacy chat, only the local player's commands are processed this way
            executeCmd(msg, player)
        end)
    end)
end

local lastResizeTime = 0
local resizeDebounceTime = 1.0
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    local currentTime = tick()
    if currentTime - lastResizeTime < resizeDebounceTime then return end
    lastResizeTime = currentTime

    task.spawn(function()
        task.wait(0.2)
        if screenGui and screenGui.Parent then
            rescaleUI()
        end
    end)
end)

task.spawn(function()
    mainFrame.Size = UDim2.new(0, 0, 0, 0)
    mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    performanceFrame.Position = UDim2.new(1, S(50), 0, S(10))

    task.wait(0.25)
    playSound("open")
    notification("2TAKE1 ULTRA - Initializing systems...", 3, "info")

    Services.Tween:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back), {
        Size = UDim2.new(0, S(isMobile and 380 or 480), 0, S(isMobile and 720 or 820)),
        Position = UDim2.new(0.5, -S(isMobile and 190 or 240), 0.5, -S(isMobile and 360 or 410)),
        Rotation = 0
    }):Play()

    Services.Tween:Create(performanceFrame, TweenInfo.new(0.6, Enum.EasingStyle.Back), {
        Position = UDim2.new(1, -S(210), 0, S(10))
    }):Play()

    task.wait(1.2)
    notification("All systems online! Press ; for commands or INSERT to toggle UI", 3, "success")
end)

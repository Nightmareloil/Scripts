-- Enhanced Spinning Sword Ball Script with 40 Rotation Modes
-- Improved performance, spinning mechanics, and visual effects
-- Keys: Z toggle spin, C cycle mode, V increase spin speed, B decrease spin speed

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local torso = character:WaitForChild("HumanoidRootPart")

-- Check if typing in textbox
local focused = false
UserInputService.TextBoxFocused:Connect(function() focused = true end)
UserInputService.TextBoxFocusReleased:Connect(function() focused = false end)

-- Collect tools from Workspace
local tools = {}
local function collectTools()
    tools = {}
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Tool") and obj.Parent == Workspace then
            table.insert(tools, obj)
        end
    end
end
collectTools()

if #tools == 0 then
    warn("No tools found in Workspace!")
    return
end

-- Enhanced Configuration
local CONFIG = {
    baseRadius = 15,
    radiusVariation = 5,
    orbitSpeed = 1.0,
    verticalOffset = 2,
    verticalVariation = 1.5,
    spinSpeed = 8,
    minSpinSpeed = 2,
    maxSpinSpeed = 25,
    spinSpeedIncrement = 2,
    updateInterval = 1/60,
    bodyPosition = {
        maxForce = Vector3.new(15000, 15000, 15000),
        p = 8000,
        d = 800
    },
    transitionSpeed = 2,
    wingAngle = 0.5,
    wingValue = 0.5
}

-- Humanoid scales
local function updateHumanoidScales()
    local heightScale = humanoid.BodyHeightScale.Value
    local depthScale = humanoid.BodyDepthScale.Value
    local widthScale = humanoid.BodyWidthScale.Value
    local hipHeight = humanoid.HipHeight
    local swordLength = 5.5
    local backDepth = 0.5 * depthScale + 0.5
    local shoulderHeight = (hipHeight / 2) * heightScale
    return heightScale, depthScale, widthScale, hipHeight, swordLength, backDepth, shoulderHeight
end

local heightScale, depthScale, widthScale, hipHeight, swordLength, backDepth, shoulderHeight = updateHumanoidScales()

-- State management
local animated = true
local flying = false
local sprinting = false
local spinEnabled = true
local currentRotationMode = 1
local modeTransition = 0

-- Performance optimization: Cache math functions
local sin, cos, abs, floor, ceil, sqrt, pi, acos, atan2 = 
    math.sin, math.cos, math.abs, math.floor, math.ceil, math.sqrt, math.pi, math.acos, math.atan2

-- 40 Enhanced Rotation Modes with smooth animations
local rotationModes = {
    -- 1: Perfect Sphere (Golden Ratio Distribution)
    function(data, t, torsoPos)
        local phi = acos(1 - 2 * data.index / data.total)
        local theta = pi * (1 + sqrt(5)) * data.index + t * 0.8
        local r = data.radius + sin(t * 0.5) * 2
        return torsoPos + Vector3.new(
            r * sin(phi) * cos(theta),
            r * cos(phi) + data.height,
            r * sin(phi) * sin(theta)
        )
    end,
    
    -- 2: Rotating Rings (Three Layers)
    function(data, t, torsoPos)
        local layer = floor((data.index - 1) / (data.total / 3))
        local phi = (layer / 3) * pi + t * 0.3
        local theta = ((data.index - 1) % (data.total / 3)) * (2 * pi / (data.total / 3)) + t * 1.5
        return torsoPos + Vector3.new(
            data.radius * sin(phi) * cos(theta),
            data.radius * cos(phi) + data.height,
            data.radius * sin(phi) * sin(theta)
        )
    end,
    
    -- 3: Spiral Galaxy
    function(data, t, torsoPos)
        local tt = data.index / data.total
        local theta = 6 * pi * tt + t * 1.5
        local r = data.radius * (0.3 + 0.7 * tt)
        local y = sin(tt * pi * 2) * 5
        return torsoPos + Vector3.new(
            r * cos(theta),
            y + data.height,
            r * sin(theta)
        )
    end,
    
    -- 4: Chaotic Orbit
    function(data, t, torsoPos)
        local phi = sin(t + data.index * 0.5) * pi
        local theta = cos(t * 1.3 + data.index * 0.3) * 2 * pi + t
        phi = abs(phi) % pi
        return torsoPos + Vector3.new(
            data.radius * sin(phi) * cos(theta),
            data.radius * cos(phi) + data.height,
            data.radius * sin(phi) * sin(theta)
        )
    end,
    
    -- 5: DNA Double Helix
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * 4 * pi + t * 1.5
        local helixNum = (data.index % 2) * pi + t * 0.2
        local yOffset = sin(tt) * 2
        return torsoPos + Vector3.new(
            data.radius * cos(tt + helixNum),
            yOffset + data.height,
            data.radius * sin(tt + helixNum)
        )
    end,
    
    -- 6: Pulsing Sphere
    function(data, t, torsoPos)
        local phi = acos(1 - 2 * data.index / data.total)
        local theta = pi * (1 + sqrt(5)) * data.index + t * 0.7
        local pulse = 1 + sin(t * 2.5) * 0.25
        local r = data.radius * pulse
        return torsoPos + Vector3.new(
            r * sin(phi) * cos(theta),
            r * cos(phi) + data.height,
            r * sin(phi) * sin(theta)
        )
    end,
    
    -- 7: Figure-8 Lemniscate
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * 2 * pi + t * 1.2
        local scale = data.radius / (1 + sin(tt)^2)
        return torsoPos + Vector3.new(
            scale * cos(tt),
            sin(tt * 2) * 3 + data.height,
            scale * sin(tt) * cos(tt)
        )
    end,
    
    -- 8: Tornado Vortex
    function(data, t, torsoPos)
        local height = ((data.index / data.total) - 0.5) * 2 + sin(t * 0.5) * 0.2
        local rad = (1 - abs(height)) * data.radius
        local theta = (data.index / data.total) * 4 * pi + t * 2.5
        return torsoPos + Vector3.new(
            cos(theta) * rad,
            height * data.radius + data.height,
            sin(theta) * rad
        )
    end,
    
    -- 9: Cool Wings
    function(data, t, torsoPos)
        local half = floor(data.total / 2)
        if half == 0 then half = 1 end
        local flap = sin(t * 3) * 0.15
        local isLeft = data.index <= half
        local wingIndex = isLeft and data.index or (data.index - half)
        wingIndex = math.max(1, wingIndex)
        local angle = ((CONFIG.wingAngle / half) * wingIndex) + CONFIG.wingValue + flap
        angle = isLeft and angle or -angle
        local x = isLeft and (-3.5 * widthScale + 1.7 * widthScale) or (3.5 * widthScale - 1.7 * widthScale)
        return torsoPos + Vector3.new(x, shoulderHeight + data.height, -backDepth)
    end,
    
    -- 10: Ninja Star Spinner
    function(data, t, torsoPos)
        local angle = (data.index - 1) / data.total * 2 * pi + t * 4
        local r = (swordLength / 2 + 0.5) * heightScale + sin(t * 2) * 1
        return torsoPos + Vector3.new(
            cos(angle) * r * widthScale,
            shoulderHeight + data.height,
            -backDepth
        )
    end,
    
    -- 11: Halo Above Head
    function(data, t, torsoPos)
        local theta = (data.index - 1) / data.total * 2 * pi + t * 1.2
        local r = data.radius * 0.6
        return torsoPos + Vector3.new(
            cos(theta) * r,
            (hipHeight + 2) * heightScale + data.height + sin(t) * 0.5,
            sin(theta) * r
        )
    end,
    
    -- 12: Shield Wall Formation
    function(data, t, torsoPos)
        local cols = ceil(sqrt(data.total))
        local row = floor((data.index - 1) / cols)
        local col = (data.index - 1) % cols
        local spacing = swordLength * 0.8
        return torsoPos + Vector3.new(
            (col - cols / 2) * spacing * widthScale + sin(t + row) * 0.5,
            (row - sqrt(data.total) / 2) * spacing + hipHeight / 2 + data.height,
            data.radius * 0.5
        )
    end,
    
    -- 13: Crown Formation
    function(data, t, torsoPos)
        local theta = (data.index - 1) / data.total * 2 * pi + t * 0.4
        local r = (swordLength / 2 + 1) * heightScale * 0.8
        return torsoPos + Vector3.new(
            cos(theta) * r,
            (hipHeight + 1.5) * heightScale + data.height + sin(t + data.index * 0.5) * 0.3,
            sin(theta) * r
        )
    end,
    
    -- 14: Dragon Tail Trail
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * data.radius
        local wave = sin(t * 1.5 + data.index * 0.4) * 0.4
        return torsoPos + Vector3.new(
            wave * widthScale,
            shoulderHeight - tt * 0.5 + data.height,
            -backDepth - tt
        )
    end,
    
    -- 15: Butterfly Wings (Dual Layer)
    function(data, t, torsoPos)
        local layers = 2
        local perLayer = floor(data.total / layers)
        local layer = floor((data.index - 1) / perLayer) + 1
        local layerIndex = (data.index - 1) % perLayer + 1
        local half = floor(perLayer / 2)
        if half == 0 then half = 1 end
        local flap = sin(t * 3.5) * 0.25 * layer
        local isLeft = layerIndex <= half
        local wingIndex = isLeft and layerIndex or (layerIndex - half)
        wingIndex = math.max(1, wingIndex)
        local angle = ((CONFIG.wingAngle / half) * wingIndex) + CONFIG.wingValue + flap
        angle = isLeft and angle or -angle
        local x = isLeft and (-3.5 * widthScale * layer + 1.7 * widthScale) or (3.5 * widthScale * layer - 1.7 * widthScale)
        return torsoPos + Vector3.new(
            x,
            shoulderHeight + data.height + (layer - 1) * 0.5,
            -backDepth - (layer - 1) * 0.3
        )
    end,
    
    -- 16: Inward Vortex Spiral
    function(data, t, torsoPos)
        local theta = (data.index / data.total) * 6 * pi + t * 2
        local r = data.radius * (1 - (data.index / data.total) * 0.5)
        return torsoPos + Vector3.new(
            cos(theta) * r,
            data.height + (data.index / data.total) * 10,
            sin(theta) * r
        )
    end,
    
    -- 17: Shield Circle Defense
    function(data, t, torsoPos)
        local theta = (data.index - 1) / data.total * 2 * pi + t * 1.5
        local r = data.radius * 0.8
        return torsoPos + Vector3.new(
            cos(theta) * r,
            data.height + hipHeight / 2,
            sin(theta) * r + data.radius * 0.5
        )
    end,
    
    -- 18: Aura Ring Glow
    function(data, t, torsoPos)
        local theta = (data.index - 1) / data.total * 2 * pi + t
        return torsoPos + Vector3.new(
            cos(theta) * data.radius,
            data.height + sin(t + theta) * 1.5,
            sin(theta) * data.radius
        )
    end,
    
    -- 19: Cube Formation
    function(data, t, torsoPos)
        local side = ceil(data.total^(1/3))
        local idx = data.index - 1
        local x = (idx % side) - side/2
        local y = floor(idx / side) % side - side/2
        local z = floor(idx / (side * side)) - side/2
        local spacing = data.radius * 0.3
        return torsoPos + Vector3.new(
            x * spacing + sin(t + x) * 0.3,
            y * spacing + data.height + sin(t + y) * 0.3,
            z * spacing + sin(t + z) * 0.3
        )
    end,
    
    -- 20: Orbital Rings (Multiple)
    function(data, t, torsoPos)
        local rings = 3
        local ring = (data.index - 1) % rings
        local perRing = ceil(data.total / rings)
        local theta = ((data.index - 1) / perRing) * 2 * pi + t * (ring + 1)
        local r = data.radius * (0.5 + ring * 0.25)
        return torsoPos + Vector3.new(
            cos(theta) * r,
            data.height + ring * 2,
            sin(theta) * r
        )
    end,
    
    -- 21: Star Burst Pattern
    function(data, t, torsoPos)
        local angle = (data.index / data.total) * 2 * pi
        local pulse = 1 + sin(t * 3) * 0.3
        local r = data.radius * pulse * (0.5 + (data.index % 2) * 0.5)
        return torsoPos + Vector3.new(
            cos(angle) * r,
            data.height + sin(angle * 5 + t) * 2,
            sin(angle) * r
        )
    end,
    
    -- 22: Wave Ripple
    function(data, t, torsoPos)
        local theta = (data.index / data.total) * 2 * pi
        local wave = sin(data.index * 0.5 - t * 2) * 3
        return torsoPos + Vector3.new(
            cos(theta) * data.radius,
            data.height + wave,
            sin(theta) * data.radius
        )
    end,
    
    -- 23: Double Helix Twist
    function(data, t, torsoPos)
        local strand = data.index % 2
        local tt = (data.index / data.total) * 6 * pi + t
        local offset = strand * pi
        return torsoPos + Vector3.new(
            cos(tt + offset) * data.radius * 0.6,
            (data.index / data.total) * 15 + data.height,
            sin(tt + offset) * data.radius * 0.6
        )
    end,
    
    -- 24: Hourglass Shape
    function(data, t, torsoPos)
        local theta = (data.index / data.total) * 4 * pi + t
        local height = ((data.index / data.total) - 0.5) * 15
        local r = data.radius * (1 - abs(height / 10))
        return torsoPos + Vector3.new(
            cos(theta) * r,
            height + data.height,
            sin(theta) * r
        )
    end,
    
    -- 25: Infinity Symbol (3D)
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * 2 * pi + t
        local scale = data.radius / (1 + sin(tt)^2)
        return torsoPos + Vector3.new(
            scale * cos(tt) * 1.5,
            data.height + sin(tt * 2) * 2,
            scale * sin(tt) * cos(tt)
        )
    end,
    
    -- 26: Pyramid Formation
    function(data, t, torsoPos)
        local layer = floor(sqrt(data.index))
        local inLayer = data.index - layer * layer
        local layerSize = layer * 2 + 1
        local x = (inLayer % layerSize) - layer
        local z = floor(inLayer / layerSize) - layer
        return torsoPos + Vector3.new(
            x * 2 + sin(t) * 0.3,
            -layer * 2 + data.height,
            z * 2 + cos(t) * 0.3
        )
    end,
    
    -- 27: Orbiting Satellites
    function(data, t, torsoPos)
        local orbit = floor((data.index - 1) / 4)
        local pos = (data.index - 1) % 4
        local theta = pos * pi / 2 + t * (orbit + 1)
        local r = data.radius + orbit * 3
        return torsoPos + Vector3.new(
            cos(theta) * r,
            data.height + sin(t + orbit) * 2,
            sin(theta) * r
        )
    end,
    
    -- 28: Lotus Flower Bloom
    function(data, t, torsoPos)
        local layer = floor(data.index / 8)
        local theta = ((data.index - 1) % 8) * pi / 4 + t * 0.5
        local r = data.radius * (0.3 + layer * 0.3)
        local bloom = sin(t * 2) * 0.5 + 0.5
        return torsoPos + Vector3.new(
            cos(theta) * r * bloom,
            data.height + layer * 2,
            sin(theta) * r * bloom
        )
    end,
    
    -- 29: Magnetic Field Lines
    function(data, t, torsoPos)
        local phi = (data.index / data.total) * pi
        local theta = t + data.index * 0.5
        local r = data.radius * sin(phi)
        return torsoPos + Vector3.new(
            r * cos(theta),
            data.radius * cos(phi) + data.height,
            r * sin(theta)
        )
    end,
    
    -- 30: Spirograph Pattern
    function(data, t, torsoPos)
        local R, r, d = data.radius, data.radius * 0.3, data.radius * 0.5
        local tt = (data.index / data.total) * 10 * pi + t
        local x = (R - r) * cos(tt) + d * cos(((R - r) / r) * tt)
        local z = (R - r) * sin(tt) - d * sin(((R - r) / r) * tt)
        return torsoPos + Vector3.new(x, data.height + sin(tt) * 2, z)
    end,
    
    -- 31: Trefoil Knot
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * 2 * pi + t * 0.8
        local x = sin(tt) + 2 * sin(2 * tt)
        local y = cos(tt) - 2 * cos(2 * tt)
        local z = -sin(3 * tt)
        local scale = data.radius * 0.3
        return torsoPos + Vector3.new(x * scale, y * scale + data.height, z * scale)
    end,
    
    -- 32: Mobius Strip
    function(data, t, torsoPos)
        local u = (data.index / data.total) * 2 * pi + t
        local v = (data.index % 2) * 2 - 1
        local r = data.radius * 0.5
        local x = (r + v * cos(u/2)) * cos(u)
        local y = (r + v * cos(u/2)) * sin(u)
        local z = v * sin(u/2) * 3
        return torsoPos + Vector3.new(x, z + data.height, y)
    end,
    
    -- 33: Torus Knot
    function(data, t, torsoPos)
        local tt = (data.index / data.total) * 2 * pi + t
        local p, q = 3, 2
        local r = data.radius * 0.5
        local R = data.radius
        local x = (R + r * cos(q * tt)) * cos(p * tt)
        local y = (R + r * cos(q * tt)) * sin(p * tt)
        local z = r * sin(q * tt)
        return torsoPos + Vector3.new(x, z + data.height, y)
    end,
    
    -- 34: Fibonacci Spiral
    function(data, t, torsoPos)
        local golden = (1 + sqrt(5)) / 2
        local theta = data.index * 2 * pi / golden + t
        local r = sqrt(data.index) * 1.5
        return torsoPos + Vector3.new(
            cos(theta) * r,
            data.height + data.index * 0.3,
            sin(theta) * r
        )
    end,
    
    -- 35: Sphere Packing
    function(data, t, torsoPos)
        local layer = floor(sqrt(data.index / pi))
        local phi = acos(1 - 2 * data.index / data.total)
        local theta = sqrt(data.total * pi) * phi + t
        local r = data.radius + layer * 2
        return torsoPos + Vector3.new(
            r * sin(phi) * cos(theta),
            r * cos(phi) + data.height,
            r * sin(phi) * sin(theta)
        )
    end,
    
    -- 36: Cylindrical Helix
    function(data, t, torsoPos)
        local theta = (data.index / data.total) * 8 * pi + t * 2
        local height = (data.index / data.total) * 15
        return torsoPos + Vector3.new(
            cos(theta) * data.radius,
            height + data.height,
            sin(theta) * data.radius
        )
    end,
    
    -- 37: Rose Curve
    function(data, t, torsoPos)
        local k = 5
        local theta = (data.index / data.total) * 2 * pi + t
        local r = data.radius * cos(k * theta)
        return torsoPos + Vector3.new(
            r * cos(theta),
            data.height + sin(theta * 3) * 2,
            r * sin(theta)
        )
    end,
    
    -- 38: Cardioid Shape
    function(data, t, torsoPos)
        local theta = (data.index / data.total) * 2 * pi + t * 0.8
        local a = data.radius * 0.5
        local r = 2 * a * (1 + cos(theta))
        return torsoPos + Vector3.new(
            r * cos(theta),
            data.height + sin(theta * 2) * 3,
            r * sin(theta)
        )
    end,
    
    -- 39: Lissajous Curves
    function(data, t, torsoPos)
        local a, b = 3, 4
        local tt = (data.index / data.total) * 2 * pi + t
        return torsoPos + Vector3.new(
            data.radius * sin(a * tt),
            data.height + data.radius * sin(b * tt + pi/2),
            data.radius * cos(tt) * 0.5
        )
    end,
    
    -- 40: Atomic Orbit Model
    function(data, t, torsoPos)
        local orbit = floor((data.index - 1) / 6)
        local pos = (data.index - 1) % 6
        local theta = pos * pi / 3 + t * (orbit + 1) * 1.5
        local phi = orbit * pi / 4
        local r = data.radius + orbit * 2
        return torsoPos + Vector3.new(
            r * sin(phi) * cos(theta),
            r * cos(phi) + data.height,
            r * sin(phi) * sin(theta)
        )
    end,
}

-- Mode names for all 40 patterns
local modeNames = {
    "Perfect Sphere", "Rotating Rings", "Spiral Galaxy", "Chaotic Orbit",
    "DNA Double Helix", "Pulsing Sphere", "Figure-8 Lemniscate", "Tornado Vortex",
    "Cool Wings", "Ninja Star Spinner", "Halo Above Head", "Shield Wall Formation",
    "Crown Formation", "Dragon Tail Trail", "Butterfly Wings", "Inward Vortex Spiral",
    "Shield Circle Defense", "Aura Ring Glow", "Cube Formation", "Orbital Rings",
    "Star Burst Pattern", "Wave Ripple", "Double Helix Twist", "Hourglass Shape",
    "Infinity Symbol", "Pyramid Formation", "Orbiting Satellites", "Lotus Flower Bloom",
    "Magnetic Field Lines", "Spirograph Pattern", "Trefoil Knot", "Mobius Strip",
    "Torus Knot", "Fibonacci Spiral", "Sphere Packing", "Cylindrical Helix",
    "Rose Curve", "Cardioid Shape", "Lissajous Curves", "Atomic Orbit Model"
}

-- Display current mode
local function displayMode()
    local msg = "Mode " .. currentRotationMode .. "/40: " .. modeNames[currentRotationMode] .. 
                "\nSpin Speed: " .. CONFIG.spinSpeed .. 
                " | Spin: " .. (spinEnabled and "ON" or "OFF")
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Rotation Mode";
        Text = msg;
        Duration = 3;
    })
end

-- Disable tool pickup
local function disableToolPickup(tool)
    if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
        local handle = tool.Handle
        tool.Enabled = false
        handle.CanCollide = false
        handle.CanTouch = false
        tool.CanBeDropped = false
        handle.Massless = true
        
        pcall(function() tool.RequiresHandle = false end)
        pcall(function() handle:SetNetworkOwner(player) end)
        
        tool.Equipped:Connect(function()
            task.wait()
            if tool.Parent == character then
                tool.Parent = Workspace
            end
        end)
        
        tool.Changed:Connect(function(prop)
            if prop == "Parent" and tool.Parent == character then
                task.wait()
                tool.Parent = Workspace
            end
        end)
    end
end

-- Initialize tools with optimized physics
local toolData = {}
local function initializeTools()
    toolData = {}
    for i, tool in ipairs(tools) do
        disableToolPickup(tool)
        local handle = tool.Handle
        if handle then
            local bp = Instance.new("BodyPosition", handle)
            bp.MaxForce = CONFIG.bodyPosition.maxForce
            bp.P = CONFIG.bodyPosition.p
            bp.D = CONFIG.bodyPosition.d
            
            local bav = Instance.new("BodyAngularVelocity", handle)
            bav.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bav.AngularVelocity = Vector3.new(0, CONFIG.spinSpeed, 0)
            
            local baseAngle = (i - 1) * (2 * pi / #tools)
            local radius = CONFIG.baseRadius + (i % 3) * CONFIG.radiusVariation
            local height = CONFIG.verticalOffset + sin(i) * CONFIG.verticalVariation
            
            toolData[tool] = {
                index = i,
                total = #tools,
                angle = baseAngle,
                radius = radius,
                height = height,
                bodyPosition = bp,
                bodyAngularVelocity = bav,
                lastPos = handle.Position
            }
            
            local t = os.clock() * CONFIG.orbitSpeed
            local targetPos = rotationModes[currentRotationMode](toolData[tool], t, torso.Position)
            bp.Position = targetPos
        end
    end
end
initializeTools()
displayMode()

-- Continuous ownership and parent protection
RunService.Heartbeat:Connect(function()
    for tool, data in pairs(toolData) do
        if tool.Parent == character then
            tool.Parent = Workspace
        end
        local handle = tool:FindFirstChild("Handle")
        if handle then
            pcall(function() handle:SetNetworkOwner(player) end)
        end
    end
end)

-- Optimized update loop
local lastUpdate = 0
RunService.Heartbeat:Connect(function()
    local now = os.clock()
    if now - lastUpdate < CONFIG.updateInterval then return end
    lastUpdate = now
    
    for tool, data in pairs(toolData) do
        if tool.Parent and tool:FindFirstChild("Handle") and data.bodyPosition then
            local success = pcall(function()
                local t = now * CONFIG.orbitSpeed
                local targetPos = rotationModes[currentRotationMode](data, t, torso.Position)
                data.bodyPosition.Position = targetPos
                
                -- Enhanced spin with variable speed
                if spinEnabled then
                    data.bodyAngularVelocity.AngularVelocity = Vector3.new(
                        sin(t + data.index) * CONFIG.spinSpeed * 0.3,
                        CONFIG.spinSpeed,
                        cos(t + data.index) * CONFIG.spinSpeed * 0.3
                    )
                else
                    data.bodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
                end
                
                data.lastPos = targetPos
            end)
        else
            if not tool.Parent or not tool:FindFirstChild("Handle") then
                if data.bodyPosition then pcall(function() data.bodyPosition:Destroy() end) end
                if data.bodyAngularVelocity then pcall(function() data.bodyAngularVelocity:Destroy() end) end
                toolData[tool] = nil
            end
        end
    end
end)

-- Enhanced input handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or focused then return end
    
    if input.KeyCode == Enum.KeyCode.Z then
        spinEnabled = not spinEnabled
        displayMode()
        
    elseif input.KeyCode == Enum.KeyCode.C then
        currentRotationMode = currentRotationMode % #rotationModes + 1
        displayMode()
        
        if currentRotationMode ~= 9 then
            animated = true
            flying = false
            sprinting = false
            humanoid.WalkSpeed = 16
            workspace.Gravity = 196.2
        end
        
    elseif input.KeyCode == Enum.KeyCode.V then
        CONFIG.spinSpeed = math.min(CONFIG.spinSpeed + CONFIG.spinSpeedIncrement, CONFIG.maxSpinSpeed)
        displayMode()
        
    elseif input.KeyCode == Enum.KeyCode.B then
        CONFIG.spinSpeed = math.max(CONFIG.spinSpeed - CONFIG.spinSpeedIncrement, CONFIG.minSpinSpeed)
        displayMode()
    end
end)

-- Handle respawn
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    torso = character:WaitForChild("HumanoidRootPart")
    heightScale, depthScale, widthScale, hipHeight, swordLength, backDepth, shoulderHeight = updateHumanoidScales()
    wait(1)
    collectTools()
    initializeTools()
    displayMode()
end)

print("Enhanced Sword Ball Script Loaded!")
print("40 Rotation Modes Available")
print("Controls:")
print("Z - Toggle Spin On/Off")
print("C - Cycle Through Modes")
print("V - Increase Spin Speed")
print("B - Decrease Spin Speed")
